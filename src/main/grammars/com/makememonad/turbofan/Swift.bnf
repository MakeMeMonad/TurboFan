/*
  Swift Language Grammar for CLion Plugin
  BEGIN FILE Swift.bnf
  References and Links:
  https://docs.swift.org/swift-book/documentation/the-swift-programming-language/aboutthelanguagereference/
  https://docs.swift.org/swift-book/documentation/the-swift-programming-language/lexicalstructure/
  https://docs.swift.org/swift-book/documentation/the-swift-programming-language/summaryofthegrammar/
  Above references are:
    Copyright © 2014–2023 Apple Inc. and the Swift project authors. All rights reserved.
    This document is made available under a Creative Commons Attribution 4.0 International (CC BY 4.0) License.
    Swift and the Swift logo are trademarks of Apple Inc.

  https://github.com/JetBrains/Grammar-Kit
  Above reference is:
    Pertinent License Info goes here...

*/

  {
  // Generates methods like `getKwIf()` etc. on composite elements
  generatePsi=true
  generateTokens=true
  generateTokenAccessors=true
  parserClass="com.makememonad.turbofan.language.swift.parser.SwiftParser"
  parserUtilClass="com.makememonad.turbofan.language.swift.parser.SwiftParserUtil"
  // implements="com.intellij.psi.tree.IElementType"
  // Common base for PSI elements
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  // Where IElementType constants go
  elementTypeHolderClass="com.makememonad.turbofan.language.swift.psi.SwiftTypes"
  // Base for element types
  elementTypeClass="com.intellij.psi.tree.IElementType"
  // Base for token types (often same as elementTypeClass)
  tokenTypeClass="com.intellij.psi.tree.IElementType"
  // e.g., Swift<RuleName> for interfaces
  psiClassPrefix="Swift"
  // e.g., SwiftImpl<RuleName> for implementations
  psiImplClassSuffix="ImplGen"
  // Where PSI interfaces go
  psiPackage="com.makememonad.turbofan.language.swift.psi"
  // Where PSI impls go
  psiImplPackage="com.makememonad.turbofan.language.swift.psi.impl"
  // For custom methods on PSI nodes
  psiImplUtilClass="com.makememonad.turbofan.language.swift.psi.impl.SwiftPsiImplUtil"
  // elementTypeFactory()= com.makememonad.turbofan.language.swift.psi.stubs.SwiftStubElementTypeFactory.create
  }
  // GRAMMAR RULE DEFINITIONS:

  // RULES: LEXICAL STRUCTURE (Mainly handled in the JFlex with tokens redefined below...
  swiftFile ::= top-level-declaration?
  top-level-declaration ::= statements
  identifier-list ::= IDENTIFIER (COMMA IDENTIFIER)*

  // RULES: TOP LEVEL WITH CUSTOMIZED INTERFACES
  declaration-name::= IDENTIFIER


  // RULES: ATTRIBUTES
  attribute ::= (OP_AT attribute-name attribute-argument-clause?) {
    methods [
      String getName()
      PsiElement getNameIdentifier()
      PsiElement setName(String name)
      PsiReference getReference()
      ItemPresentation getPresentation()
      PsiElement getDocumentationTarget()
    ]
  }
  attribute-name ::= IDENTIFIER
  private attribute-argument-clause ::= (LPAREN balanced-tokens? RPAREN)
  private attributes ::= attribute (attribute)*

  // RULES: ACTOR DECLARATION
  actor-declaration ::= attributes? access-level-modifier? KW_ACTOR actor-name generic-parameter-clause? type-inheritance-clause? generic-where-clause? actor-body {
    methods [
      String getName()
      PsiElement getNameIdentifier()
      PsiElement setName(String name)
      PsiReference getReference()
      ItemPresentation getPresentation()
      PsiElement getDocumentationTarget()
    ]
  }
  actor-name ::= IDENTIFIER
  private actor-body ::= (LBRACE actor-members? RBRACE)
  private actor-members ::= actor-member (actor-member)*
  private actor-member ::= declaration | compiler-control-statement

    // RULES: CLASS DECLARATION
  class-declaration ::= attributes? class-access KW_CLASS class-name generic-parameter-clause? type-inheritance-clause? generic-where-clause? class-body {
  methods [
    String getName()
    PsiElement getNameIdentifier()
    PsiElement setName(String name)
    PsiReference getReference()
    ItemPresentation getPresentation()
    PsiElement getDocumentationTarget()
  ]
  }
  class-name ::= IDENTIFIER
  private class-access ::= (KW_FINAL access-level-modifier?) | (access-level-modifier? KW_FINAL?)
  private class-body ::= (LBRACE class-members? RBRACE)
  class-members ::= class-member (class-member)*
  private class-member ::= declaration | compiler-control-statement


  constant-declaration ::= attributes? declaration-modifiers? KW_LET pattern-initializer-list {
  methods [
    List<String> getDeclaredNames()
    List<PsiElement> getDeclaredIdentifiers()
    PsiReference getReference()
    ItemPresentation getPresentation()
    PsiElement getDocumentationTarget()
   ]
  }
  pattern-initializer-list ::= pattern-initializer (COMMA pattern-initializer)*
  private pattern-initializer ::= (pattern initializer?)
  private initializer ::= OP_ASSIGNMENT expression

  // RULES: DECLARATION MODIFIERS
  declaration-modifiers ::= declaration-modifier (declaration-modifier)* {
    methods [
    ]
  }
  private declaration-modifier ::= KW_CLASS | KW_CONVENIENCE | KW_DYNAMIC | KW_FINAL | KW_INFIX | KW_LAZY | KW_OPTIONAL | KW_OVERRIDE | KW_POSTFIX | KW_PREFIX | KW_REQUIRED | KW_STATIC | KW_UNOWNED (LPAREN (KW_SAFE | KW_UNSAFE) RPAREN)? | KW_WEAK | access-level-modifier | mutation-modifier | KW_NONISOLATED
  private access-level-modifier ::= KW_PRIVATE (LPAREN KW_SET RPAREN)? | KW_FILEPRIVATE (LPAREN KW_SET RPAREN)? | KW_INTERNAL (LPAREN KW_SET RPAREN)? | KW_PACKAGE (LPAREN KW_SET RPAREN)? | KW_PUBLIC (LPAREN KW_SET RPAREN)? | KW_OPEN (LPAREN KW_SET RPAREN)?
  private mutation-modifier ::= KW_MUTATING | KW_NONMUTATING

  // RULES: ENUM DECLARATION
  enum-declaration ::= attributes? access-level-modifier? (union-style-enum | raw-value-style-enum) {
    methods [
      String getName()
      PsiElement getNameIdentifier()
      PsiElement setName(String name)
      PsiReference getReference()
      ItemPresentation getPresentation()
      PsiElement getDocumentationTarget()
   ]
  }
  union-style-enum ::= (KW_INDIRECT? KW_ENUM enum-declaration-name) generic-parameter-clause? type-inheritance-clause? generic-where-clause? (LBRACE union-style-enum-members? RBRACE)
  private union-style-enum-members ::= union-style-enum-member (union-style-enum-member)*
  private union-style-enum-member ::= declaration | union-style-enum-case-clause | compiler-control-statement
  private union-style-enum-case-clause ::= attributes? KW_INDIRECT? KW_CASE union-style-enum-case-list
  private union-style-enum-case-list ::= union-style-enum-case (COMMA union-style-enum-case)*
  private union-style-enum-case ::= enum-case-name tuple-type?
  enum-declaration-name ::= IDENTIFIER
  enum-case-name ::= IDENTIFIER
  raw-value-style-enum ::= KW_ENUM enum-declaration-name generic-parameter-clause? type-inheritance-clause generic-where-clause? (LBRACE raw-value-style-enum-members RBRACE)
  private raw-value-style-enum-members ::= raw-value-style-enum-member (raw-value-style-enum-member)*
  private raw-value-style-enum-member ::= declaration | raw-value-style-enum-case-clause | compiler-control-statement
  private raw-value-style-enum-case-clause ::= attributes? KW_CASE raw-value-style-enum-case-list
  private raw-value-style-enum-case-list ::= raw-value-style-enum-case (COMMA raw-value-style-enum-case)*
  private raw-value-style-enum-case ::= enum-case-name raw-value-assignment?
  private raw-value-assignment ::= (OP_ASSIGNMENT raw-value-literal)
  private raw-value-literal ::= numeric-literal | static-string-literal | boolean-literal

    // RULES: EXTENSION DECLARATION
  extension-declaration ::= attributes? access-level-modifier? KW_EXTENSION type-identifier type-inheritance-clause? generic-where-clause? extension-body {
    methods [
    ItemPresentation getPresentation()
    ]
  }
    private extension-body ::= (LBRACE extension-members? RBRACE)
    extension-members ::= extension-member (extension-member)*
    private extension-member ::= declaration | compiler-control-statement

    // RULES: FUNCTION DECLARATION
  function-declaration ::= function-head function-declaration-name generic-parameter-clause? function-signature generic-where-clause?  code-block? {
    methods [
    String getName()
    PsiElement getNameIdentifier()
    PsiElement setName(String name)
    PsiReference getReference()
    ItemPresentation getPresentation()
    PsiElement getDocumentationTarget()
    SwiftFunctionBody getBody()
    List<SwiftParameter> getParameters()
    List<String> getParameterNames()
    SwiftType getReturnType()
    boolean isAsync()
    boolean isThrows()
    boolean isStatic()
    ]
  }
  private function-head ::= attributes? declaration-modifiers? KW_FUNC
  function-declaration-name ::= IDENTIFIER | OPERATOR
  private function-signature ::= parameter-clause KW_ASYNC? (KW_RETHROWS | throws-clause?) function-result?
  private function-result ::= (KW_FWD_ARROW attributes? type)
  private parameter-clause ::= (LPAREN parameter-list? RPAREN)
  private parameter-list ::= parameter (COMMA parameter)*
  private parameter ::= external-parameter-name? IDENTIFIER parameter-type-annotation (KW_ELLIPSIS | default-argument-clause?)?
  private external-parameter-name ::= IDENTIFIER
  // internal-parameter-name ::= CHECK THE SPEC AND MAYBE BRING THIS BACK
  private parameter-type-annotation ::= COLON attributes? parameter-modifier? type
  private parameter-modifier ::= KW_INOUT | KW_BORROWING | KW_CONSUMING
  private default-argument-clause ::= OP_ASSIGNMENT expression

  // RULES: IMPORT DECLARATION
  import-declaration ::= attributes? KW_IMPORT import-kind? import-path {
    methods [
    String getName()
    PsiElement getNameIdentifier()
    PsiReference getReference()
    ItemPresentation getPresentation()
    PsiElement getDocumentationTarget()
    ]
  }
  import-kind ::= KW_TYPEALIAS | KW_STRUCT | KW_CLASS | KW_ENUM | KW_LOWER_PROTOCOL_DECL | KW_LET | KW_VAR | KW_FUNC
  import-path ::= IDENTIFIER (DOT IDENTIFIER)?

  // RULES: INIT AND DEINIT DECLARATION
  deinitializer-declaration ::= (attributes? KW_DEINIT code-block) {
      methods [
      ]
  }
  initializer-declaration ::= initializer-head generic-parameter-clause? parameter-clause KW_ASYNC? (KW_RETHROWS | throws-clause?) generic-where-clause? code-block {
    methods [
    PsiReference getReference()
    ItemPresentation getPresentation()
    PsiElement getDocumentationTarget()
    ]
  }
  private initializer-head ::= (attributes? declaration-modifiers? (KW_INIT (OP_QUESTION | OP_NOT)? ))

  // RULES: MACRO DECLARATION
  macro-declaration ::= macro-head macro-name generic-parameter-clause? macro-signature macro-definition? generic-where-clause {
    methods [
    String getName()
    PsiElement getNameIdentifier()
    PsiElement setName(String name)
    PsiReference getReference()
    ItemPresentation getPresentation()
    PsiElement getDocumentationTarget()
    ]
  }
  macro-name ::= IDENTIFIER
  private macro-head ::= (attributes? declaration-modifiers? KW_MACRO)
  private macro-signature ::= (parameter-clause (KW_FWD_ARROW type)?)
  private macro-definition ::= (OP_ASSIGNMENT expression)

    // RULES: OPERATOR DECLARATION
  operator-declaration ::= prefix-operator-declaration | postfix-operator-declaration | infix-operator-declaration {
    methods [
    ]
  }
    private prefix-operator-declaration ::= KW_PREFIX KW_OPERATOR OPERATOR
    private postfix-operator-declaration ::= KW_POSTFIX KW_OPERATOR OPERATOR
    private infix-operator-declaration ::= KW_INFIX KW_OPERATOR OPERATOR infix-operator-group?
    private infix-operator-group ::= (COLON precedence-group-name)


  precedence-group-declaration ::= KW_PRECEDENCEGROUP precedence-group-name (LBRACE precedence-group-attributes? RBRACE) {
  methods [
    String getName()
    PsiElement getNameIdentifier()
    PsiElement setName(String name)
    PsiReference getReference()
    ItemPresentation getPresentation()
    PsiElement getDocumentationTarget()
    ]
  }

    // RULES: PROTOCOL DECLARATION
  protocol-declaration ::= attributes? access-level-modifier? KW_LOWER_PROTOCOL_DECL protocol-name type-inheritance-clause? generic-where-clause? protocol-body {
    methods [
    String getName()
    PsiElement getNameIdentifier()
    PsiElement setName(String name)
    PsiReference getReference()
    ItemPresentation getPresentation()
    PsiElement getDocumentationTarget()
    ]
  }
  protocol-name ::= IDENTIFIER
  private protocol-body ::= (LBRACE protocol-members? RBRACE)
  private protocol-members ::= protocol-member (protocol-member)*
  private protocol-member ::= protocol-member-declaration | compiler-control-statement
  private protocol-member-declaration ::=
  // protocol-property-declaration |
  protocol-method-declaration | protocol-initializer-declaration | protocol-subscript-declaration | protocol-associated-type-declaration | typealias-declaration | variable-declaration-head variable-name type-annotation getter-setter-keyword-block
  private protocol-method-declaration ::= function-head function-declaration-name generic-parameter-clause? function-signature generic-where-clause?
  private protocol-initializer-declaration ::= initializer-head generic-parameter-clause? parameter-clause throws-clause? generic-where-clause? | initializer-head generic-parameter-clause? parameter-clause KW_RETHROWS generic-where-clause?
  private protocol-subscript-declaration ::= subscript-head subscript-result generic-where-clause? getter-setter-keyword-block
  private protocol-associated-type-declaration ::= attributes? access-level-modifier? KW_ASSOCIATEDTYPE typealias-name type-inheritance-clause? typealias-assignment? generic-where-clause?

    // RULES: STRUCT DECLARATION
  struct-declaration ::= attributes? access-level-modifier? KW_STRUCT struct-name generic-parameter-clause? type-inheritance-clause? generic-where-clause? struct-body {
  methods [
    String getName()
    PsiElement getNameIdentifier()
    PsiElement setName(String name)
    PsiReference getReference()
    ItemPresentation getPresentation()
    PsiElement getDocumentationTarget()
  ]
  }
    struct-name ::= IDENTIFIER
    private struct-body ::= (LBRACE struct-members? RBRACE)
    private struct-members ::= struct-member (struct-member)*
    private struct-member ::= declaration | compiler-control-statement

    // RULES: SUBSCRIPT DECLARATION
  subscript-declaration ::= subscript-head subscript-result generic-where-clause? (code-block | getter-setter-block | getter-setter-keyword-block) {
      methods [
      ]
  }
    private subscript-head ::= attributes? declaration-modifiers? KW_SUBSCRIPT generic-parameter-clause? parameter-clause
    private subscript-result ::= (KW_FWD_ARROW attributes? type)

  // RULES: TYPEALIAS DECLARATION
  typealias-declaration ::= attributes? access-level-modifier? KW_TYPEALIAS typealias-name generic-parameter-clause? typealias-assignment {
    methods [
      String getName()
      PsiElement getNameIdentifier()
      PsiElement setName(String name)
      PsiReference getReference()
      ItemPresentation getPresentation()
      PsiElement getDocumentationTarget()
    ]
  }
    typealias-name ::= IDENTIFIER
    typealias-assignment ::= OP_ASSIGNMENT type

  // RULES: VARIABLE DECLARATION
  variable-declaration ::= variable-declaration-head (pattern-initializer-list | variable-name (type-annotation (code-block | getter-setter-block | getter-setter-keyword-block ) | initializer willSet-didSet-block | type-annotation initializer? willSet-didSet-block)) {
    methods [
      String getName()
      PsiElement getNameIdentifier()
      PsiElement setName(String name)
      PsiReference getReference()
      ItemPresentation getPresentation()
      PsiElement getDocumentationTarget()
    ]
  }
  variable-declaration-head ::= attributes? declaration-modifiers? KW_VAR
  variable-name ::= IDENTIFIER


  // RULES: LITERALS

  // RULES: LITERAL GROUPS
  literal ::= numeric-literal | string-literal | regular-expression-literal | boolean-literal | nil-literal
  numeric-literal ::= OP_SUB? integer-literal | OP_SUB? floating-point-literal
  boolean-literal ::= KW_TRUE | KW_FALSE
  private nil-literal ::= KW_NIL
  integer-literal ::= BINARY_LITERAL | OCTAL_LITERAL | DECIMAL_LITERAL | HEXADECIMAL_LITERAL
  private floating-point-literal ::= DECIMAL_FLOATING_POINT_LITERAL | HEX_FLOATING_POINT_LITERAL

  // RULES: STRING LITERALS
  string-literal ::= static-string-literal | interpolated-string-literal
  //string-literal-opening-delimiter → extended-string-literal-delimiter? "
  //string-literal-closing-delimiter → " extended-string-literal-delimiter?
  static-string-literal ::= singleline-string | multiline-string
  singleline-string ::= (STRING_START STRING_TEXT* STRING_END)
  multiline-string ::= (MULTILINE_STRING_START MULTILINE_STRING_TEXT* MULTILINE_STRING_END)
  //multiline-string-literal-opening-delimiter → extended-string-literal-delimiter? """
  //multiline-string-literal-closing-delimiter → """ extended-string-literal-delimiter?
  //extended-string-literal-delimiter → # extended-string-literal-delimiter?
  private interpolated-string-literal ::= (STRING_START interpolated-text? STRING_END) | (MULTILINE_STRING_START multiline-interpolated-text? MULTILINE_STRING_END)
  private interpolated-text ::= interpolated-text-item interpolated-text-item*
  private interpolated-text-item ::= (STRING_INTERPOLATION_START expression STRING_INTERPOLATION_END) | STRING_TEXT
  private multiline-interpolated-text ::= multiline-interpolated-text-item multiline-interpolated-text*
  private multiline-interpolated-text-item ::= (STRING_INTERPOLATION_START expression STRING_INTERPOLATION_END) | MULTILINE_STRING_TEXT

  // RULES: REGEX LITERALS
  regular-expression-literal ::= REGEXP_LITERAL
  //regular-expression-literal-opening-delimiter → extended-regular-expression-literal-delimiter? /
  //regular-expression-literal-closing-delimiter → / extended-regular-expression-literal-delimiter?
  //extended-regular-expression-literal-delimiter → # extended-regular-expression-literal-delimiter?

  // RULES: OPERATOR LITERALS
  infix-operator ::= OPERATOR
  prefix-operator ::= OPERATOR
  postfix-operator ::= OPERATOR


  // RULES: TYPES
  type ::= (LPAREN? base-type RPAREN?) (optional-type-suffix | implicitly-unwrapped-optional-type-suffix | metatype-type-suffix)?
  private base-type ::= function-type | array-type | dictionary-type | type-identifier | tuple-type | protocol-composition-type | opaque-type | KW_UPPER_ANY | KW_UPPER_SELF
  private optional-type-suffix ::= OP_QUESTION
  private implicitly-unwrapped-optional-type-suffix ::= OP_NOT
  private metatype-type-suffix ::= (DOT KW_UPPER_TYPE | DOT KW_UPPER_PROTOCOL)
  private type-annotation ::= COLON attributes? KW_INOUT? type
  private type-identifier ::= type-name generic-argument-clause? (DOT type-name generic-argument-clause?)*
  private type-name ::= IDENTIFIER
  // RULES: TUPLE TYPE
  private tuple-type ::= LPAREN (tuple-type-element (COMMA tuple-type-element)+)? RPAREN
  private tuple-type-element ::= IDENTIFIER type-annotation | type
  // RULES: FUNCTION TYPE
  function-type ::= attributes? function-arguments-clause KW_ASYNC? throws-clause? KW_FWD_ARROW type
  private function-arguments-clause ::= LPAREN (function-arguments-list KW_ELLIPSIS?)? RPAREN
  function-arguments-list ::= function-argument (COMMA function-argument)*
  function-argument ::= attributes? KW_INOUT? type | IDENTIFIER type-annotation
  private throws-clause ::= KW_THROWS (LPAREN type RPAREN)?
  // RULES: ARRAY TYPE
  private array-type ::= LBRACKET type RBRACKET
  // RULES: DICT TYPE
  private dictionary-type ::= LBRACKET type COLON type RBRACKET
  // RULES: OPTIONAL TYPES/OTHER
  protocol-composition-type ::= (type-identifier (OP_BITWISE_AND type-identifier)+)
  opaque-type ::= (KW_SOME type)
  boxed-protocol-type ::= (KW_LOWER_ANY type)
  type-inheritance-clause ::= COLON type-inheritance-list
  private type-inheritance-list ::= attributes? type-identifier (COMMA attributes? type-identifier)*


  // RULES: EXPRESSIONS
  expression ::= try-operator? KW_AWAIT? prefix-expression infix-expressions?
  private prefix-expression ::= prefix-operator? postfix-expression | in-out-expression
  private in-out-expression ::= (OP_BITWISE_AND primary-expression)
  private try-operator ::= KW_TRY (OP_QUESTION | OP_NOT)?
  private infix-expressions ::= infix-expression (infix-expression)*
  private infix-expression ::= infix-operator prefix-expression | OP_ASSIGNMENT try-operator? KW_AWAIT? prefix-expression | conditional-operator try-operator? KW_AWAIT? prefix-expression | type-casting-operator
  private conditional-operator ::= (OP_QUESTION expression COLON)
  private type-casting-operator ::= (OP_TYPE_CHECK | OP_TYPE_CAST (OP_QUESTION | OP_NOT)?) type
  private primary-expression ::= IDENTIFIER generic-argument-clause? | literal-expression | self-expression | superclass-expression | conditional-expression | closure-expression | parenthesized-expression | tuple-expression | implicit-member-expression | wildcard-expression | macro-expansion-expression | key-path-expression | selector-expression | key-path-string-expression
  private literal-expression ::= literal | array-literal | dictionary-literal | playground-literal
  private array-literal ::= (LBRACKET array-literal-items? COMMA? RBRACKET)
  private array-literal-items ::= expression (COMMA expression)*
  private dictionary-literal ::= (LBRACKET dictionary-literal-items COMMA? RBRACKET) | (LBRACKET COLON RBRACKET)
  private dictionary-literal-items ::= dictionary-literal-item (COMMA dictionary-literal-item)*
  private dictionary-literal-item ::= (expression COLON expression)
  private playground-literal ::= (KW_PND_COLORLITERAL (LPAREN (("red" COLON expression) COMMA) (("green" COLON expression) COMMA) (("blue" COLON expression) COMMA) (("alpha" COLON expression) COMMA?) RPAREN)) | (KW_PND_FILELITERAL | KW_PND_IMAGELITERAL) (LPAREN "resourceName" COLON expression RPAREN)
  private self-expression ::= KW_LOWER_SELF | self-method-expression | self-subscript-expression | self-initializer-expression
  private self-method-expression ::= (KW_LOWER_SELF DOT IDENTIFIER)
  private self-subscript-expression ::= KW_LOWER_SELF (LBRACKET function-call-argument-list RBRACKET)
  private self-initializer-expression ::= (KW_LOWER_SELF DOT KW_INIT)
  private superclass-expression ::= superclass-method-expression | superclass-subscript-expression | superclass-initializer-expression
  private superclass-method-expression ::= (KW_SUPER DOT IDENTIFIER)
  private superclass-subscript-expression ::= KW_SUPER LBRACKET function-call-argument-list RBRACKET
  private superclass-initializer-expression ::= KW_SUPER DOT KW_INIT
  conditional-expression ::= if-expression | switch-expression
  private if-expression ::= KW_IF condition-list (LBRACE statement RBRACE) if-expression-tail
  private if-expression-tail ::= KW_ELSE (if-expression | LBRACE statement RBRACE)
  private switch-expression ::= KW_SWITCH expression (LBRACE switch-expression-cases RBRACE)
  private switch-expression-cases ::= switch-expression-case (switch-expression-case)*
  private switch-expression-case ::= case-label statement | default-label statement
  private closure-expression ::= (LBRACE attributes? closure-signature? statements? RBRACE)
  private closure-signature ::= capture-list? closure-parameter-clause async? throws-clause? function-result? KW_IN | capture-list KW_IN
  private closure-parameter-clause ::= LPAREN (closure-parameter-list)? RPAREN | identifier-list
  private closure-parameter-list ::= closure-parameter (COMMA closure-parameter)*
  private closure-parameter ::= IDENTIFIER type-annotation? | IDENTIFIER type-annotation ELLIPSIS
  private capture-list ::= (LBRACKET capture-list-items RBRACKET)
  private capture-list-items ::= capture-list-item (COMMA capture-list-item)*
  private capture-list-item ::= capture-specifier? IDENTIFIER | capture-specifier? IDENTIFIER OP_ASSIGNMENT expression | capture-specifier? self-expression
  private capture-specifier ::= KW_WEAK | KW_UNOWNED | KW_UNOWNED LPAREN KW_SAFE RPAREN | KW_UNOWNED LPAREN KW_UNSAFE RPAREN
  private implicit-member-expression ::= DOT IDENTIFIER | DOT IDENTIFIER DOT postfix-expression
  private parenthesized-expression ::= (LPAREN expression RPAREN)
  private tuple-expression ::= (LPAREN (tuple-element COMMA tuple-element-list)? RPAREN)
  private tuple-element-list ::= tuple-element (COMMA tuple-element)*
  private tuple-element ::= expression | (IDENTIFIER COLON expression)
  private wildcard-expression ::= OP_UNDERSCORE
  private macro-expansion-expression ::= POUND IDENTIFIER generic-argument-clause? function-call-argument-clause? trailing-closures?
  private key-path-expression ::= (BACKSLASH type? DOT key-path-components)
  private key-path-components ::= key-path-component (DOT key-path-component)*
  private key-path-component ::= IDENTIFIER key-path-postfixes? | key-path-postfixes
  private key-path-postfixes ::= key-path-postfix (key-path-postfix)*
  private key-path-postfix ::= OP_QUESTION | OP_NOT | KW_LOWER_SELF | (LBRACKET function-call-argument-list RBRACKET)
  private selector-expression ::= KW_PND_SELECTOR (LPAREN expression RPAREN) | KW_PND_SELECTOR (LPAREN "getter" COLON expression RPAREN) | KW_PND_SELECTOR (LPAREN "setter" COLON expression RPAREN)
  private key-path-string-expression ::= KW_PND_KEYPATH (LPAREN expression RPAREN)
  private postfix-expression ::= base-postfix-expression (postfix-operator | function-call-expression | initializer-expression | explicit-member-expression | postfix-self-expression | subscript-expression | forced-value-expression | optional-chaining-expression)?
  private base-postfix-expression ::= primary-expression
  private function-call-expression ::= (function-call-argument-clause | (function-call-argument-clause? trailing-closures))
  private function-call-argument-clause ::= (LPAREN function-call-argument-list? RPAREN)
  private function-call-argument-list ::= function-call-argument (COMMA function-call-argument)*
  private function-call-argument ::= (IDENTIFIER COLON )? (expression | OPERATOR)
  private trailing-closures ::= closure-expression (IDENTIFIER COLON closure-expression)*
  private initializer-expression ::= (DOT KW_INIT) (LPAREN argument-names RPAREN)?
  private explicit-member-expression ::= (DOT DECIMAL_LITERAL | DOT IDENTIFIER (LPAREN argument-names RPAREN | generic-argument-clause?) | conditional-compilation-block)
  private argument-names ::= argument-name (argument-name)*
  private argument-name ::= (IDENTIFIER COLON)
  private postfix-self-expression ::= (DOT KW_LOWER_SELF)
  private subscript-expression ::= (LBRACKET function-call-argument-list RBRACKET)
  private forced-value-expression ::= (OP_NOT)
  private optional-chaining-expression ::= (OP_QUESTION)


  // RULES: STATEMENTS
  statement ::= (expression | declaration | loop-statement | branch-statement | labeled-statement | control-transfer-statement | defer-statement | do-statement) SEMICOLON? | compiler-control-statement
  statements ::= statement (statement)*
  private loop-statement ::= for-in-statement | while-statement | repeat-while-statement
  private for-in-statement ::= KW_FOR KW_CASE? pattern KW_IN expression where-clause? code-block
  private while-statement ::= KW_WHILE condition-list code-block
  condition-list ::= condition (COMMA condition)*
  private condition ::= expression | availability-condition | case-condition | optional-binding-condition
  private case-condition ::= KW_CASE pattern initializer
  private optional-binding-condition ::= (KW_LET | KW_VAR) pattern initializer?
  private repeat-while-statement ::= KW_REPEAT code-block KW_WHILE expression
  private branch-statement ::= if-statement | guard-statement | switch-statement
  private if-statement ::= KW_IF condition-list code-block else-clause?
  private else-clause ::= KW_ELSE (code-block | if-statement)
  private guard-statement ::= KW_GUARD condition-list KW_ELSE code-block
  private switch-statement ::= switch expression (LBRACE switch-cases? RBRACE)
  private switch-cases ::= switch-case (switch-case)*
  private switch-case ::= case-label statements | default-label statements | conditional-switch-case
  private case-label ::= attributes? KW_CASE case-item-list COLON
  private case-item-list ::= pattern where-clause? (COMMA pattern where-clause?)*
  private default-label ::= attributes? (KW_DEFAULT COLON)
  where-clause ::= (KW_WHERE where-expression)
  private where-expression ::= expression
  conditional-switch-case ::= switch-if-directive-clause switch-elseif-directive-clauses? switch-else-directive-clause? endif-directive
  private switch-if-directive-clause ::= if-directive compilation-condition switch-cases?
  private switch-elseif-directive-clauses ::= elseif-directive-clause (elseif-directive-clause)*
  private switch-elseif-directive-clause ::= elseif-directive compilation-condition switch-cases?
  private switch-else-directive-clause ::= else-directive switch-cases?
  labeled-statement ::= statement-label (loop-statement | if-statement | switch-statement | do-statement)
  statement-label ::= (label-name COLON)
  label-name ::= IDENTIFIER
  control-transfer-statement ::= break-statement | continue-statement | fallthrough-statement | return-statement | throw-statement
  private break-statement ::= KW_BREAK label-name?
  private continue-statement ::= KW_CONTINUE label-name?
  private fallthrough-statement ::= KW_FALLTHROUGH
  private return-statement ::= return expression?
  private throw-statement ::= throw expression
  defer-statement ::= KW_DEFER code-block
  private do-statement ::= KW_DO throws-clause? code-block catch-clauses?
  private catch-clauses ::= catch-clause (catch-clause)*
  private catch-clause ::= KW_CATCH catch-pattern-list? code-block
  private catch-pattern-list ::= catch-pattern (COMMA catch-pattern)*
  private catch-pattern ::= (pattern where-clause?)
  compiler-control-statement ::= conditional-compilation-block | line-control-statement
  conditional-compilation-block ::= if-directive-clause elseif-directive-clauses? else-directive-clause? endif-directive
  private if-directive-clause ::= if-directive compilation-condition statements?
  private elseif-directive-clauses ::= elseif-directive-clause (elseif-directive-clause)*
  private elseif-directive-clause ::= elseif-directive compilation-condition statements?
  private else-directive-clause ::= else-directive statements?
  private if-directive ::= KW_PND_IF
  private elseif-directive ::= KW_PND_ELSEIF
  private else-directive ::= KW_PND_ELSE
  private endif-directive ::= KW_PND_ENDIF
  private compilation-condition ::= base-compilation-condition | (LPAREN base-compilation-condition RPAREN) | (base-compilation-condition (OP_LOGICAL_AND | OP_LOGICAL_OR) base-compilation-condition)
  private base-compilation-condition ::= platform-condition | IDENTIFIER | boolean-literal | (OP_NOT compilation-condition)
  private platform-condition ::= "os" (LPAREN operating-system RPAREN) | "arch" (LPAREN architecture RPAREN) | "swift" (LPAREN (OP_GREATER_THAN_OR_EQ | OP_LANGLE) swift-version RPAREN) | "compiler" (LPAREN (OP_LESS_THAN_OR_EQ | OP_LANGLE) swift-version RPAREN) | "canImport" (LPAREN import-path RPAREN) | "targetEnvironment" (LPAREN environment RPAREN)
  private operating-system ::= "macOS" | "iOS" | "watchOS" | "tvOS" | "visionOS" | "Linux" | "Windows"
  private architecture ::= "i386" | "x86_64" | "arm" | "arm64"
  private swift-version ::= DECIMAL_LITERAL (DOT DECIMAL_LITERAL)*
  private environment ::= "simulator" | "macCatalyst"
  private line-control-statement ::= KW_PND_SOURCELOCATION (LPAREN ("file" COLON file-path COMMA "line" COLON line-number)? RPAREN)
  private line-number ::= DECIMAL_LITERAL
  private file-path ::= static-string-literal
  private availability-condition ::= KW_PND_AVAILABLE (LPAREN availability-arguments RPAREN) | KW_PND_UNAVAILABLE (LPAREN availability-arguments RPAREN)
  private availability-arguments ::= availability-argument (COMMA availability-argument)*
  private availability-argument ::= platform-name (DECIMAL_LITERAL | DECIMAL_FLOATING_POINT_LITERAL) | OP_MULT
  private platform-name ::= "iOS" | "iOSApplicationExtension" | "macOS" | "macOSApplicationExtension" | "macCatalyst" | "macCatalystApplicationExtension" | "watchOS" | "watchOSApplicationExtension" | "tvOS" | "tvOSApplicationExtension" | "visionOS" | "visionOSApplicationExtension"


  // RULES: DECLARATIONS
  declaration ::= import-declaration | constant-declaration | variable-declaration | typealias-declaration | function-declaration | enum-declaration | struct-declaration | class-declaration | actor-declaration | protocol-declaration | initializer-declaration | deinitializer-declaration | extension-declaration | subscript-declaration | operator-declaration | precedence-group-declaration
  code-block ::= (LBRACE statements? RBRACE)
  getter-setter-block ::= code-block | (LBRACE getter-clause setter-clause? RBRACE) | (LBRACE setter-clause getter-clause RBRACE)
  getter-clause ::= attributes? mutation-modifier? KW_GET code-block
  setter-clause ::= attributes? mutation-modifier? KW_SET setter-name? code-block
  setter-name ::= (LPAREN IDENTIFIER RPAREN)
  getter-setter-keyword-block ::= (LBRACE getter-keyword-clause setter-keyword-clause? RBRACE) | (LBRACE setter-keyword-clause getter-keyword-clause RBRACE)
  getter-keyword-clause ::= attributes? mutation-modifier? KW_GET
  setter-keyword-clause ::= attributes? mutation-modifier? KW_SET
  willSet-didSet-block ::= (LBRACE willSet-clause didSet-clause? RBRACE) | (LBRACE didSet-clause willSet-clause? RBRACE)
  willSet-clause ::= attributes? KW_WILLSET setter-name? code-block
  didSet-clause ::= attributes? KW_DIDSET setter-name? code-block

  // RULES: PRECEDENCE GROUP DECLARATION
  private precedence-group-attributes ::= precedence-group-attribute (precedence-group-attribute)*
  private precedence-group-attribute ::= precedence-group-relation | precedence-group-assignment | precedence-group-associativity
  private precedence-group-relation ::= (KW_HIGHER_THAN COLON |  KW_LOWER_THAN COLON) precedence-group-names
  private precedence-group-assignment ::= KW_ASSIGNMENT COLON boolean-literal
  private precedence-group-associativity ::= (KW_ASSOCIATIVITY COLON ("left" | "right" | "none"))
  private precedence-group-names ::= precedence-group-name (COMMA precedence-group-name)*
  private precedence-group-name ::= IDENTIFIER

  // RULES: BALANCED TOKENS
  private balanced-tokens ::= balanced-token (balanced-token)*
  private balanced-token ::= base-balanced-token | ((LPAREN | LBRACKET | LBRACE) base-balanced-token? (RPAREN | RBRACKET | RBRACE))
  private base-balanced-token ::= IDENTIFIER | any-keyword | literal | OPERATOR | balanced-token-punctuation


  // RULES: PATTERNS
  pattern ::= base-pattern type-casting-suffix?
  | type-checking-pattern {
    methods [
      collectNames()
    ]
  }
  private base-pattern ::=
  ((wildcard-pattern | identifier-pattern | tuple-pattern) type-annotation?)
    | value-binding-pattern
    | enum-case-pattern
    | optional-pattern
    | expression-pattern
  private type-casting-suffix ::= (OP_TYPE_CAST type)
  private type-checking-pattern ::= (OP_TYPE_CHECK type)
  private wildcard-pattern ::= KW_UNDERSCORE
  identifier-pattern ::= IDENTIFIER {
    methods [
      getName()
      getNameIdentifier()
      setName()
    ]
  }
  private value-binding-pattern ::= (KW_VAR | KW_LET) pattern
  private tuple-pattern ::= (LPAREN tuple-pattern-element-list? RPAREN)
  private tuple-pattern-element-list ::= tuple-pattern-element (COMMA tuple-pattern-element)*
  tuple-pattern-element ::= pattern | tuple-pattern-element-name {
    methods[
    getNameIdentifier()
    ]
  }
  tuple-pattern-element-name ::= IDENTIFIER COLON pattern {
    methods [
      getName()
      setName()
    ]
  }
  private enum-case-pattern ::= type-identifier? DOT enum-case-name tuple-pattern?
  private optional-pattern ::= identifier-pattern OP_QUESTION
  private expression-pattern ::= expression

  // RULES: GENERIC PARAMETERS and ARGUMENTS
  private generic-parameter-clause ::= (OP_LANGLE generic-parameter-list OP_RANGLE)
  private generic-parameter-list ::= generic-parameter (COMMA generic-parameter)*
  private generic-parameter ::= type-name (COLON type-identifier | COLON protocol-composition-type)?
  private generic-where-clause ::= (KW_WHERE requirement-list)
  private requirement-list ::= requirement (COMMA requirement)*
  private requirement ::= conformance-requirement | same-type-requirement
  private conformance-requirement ::= (type-identifier COLON (type-identifier | protocol-composition-type))
  private same-type-requirement ::= (type-identifier OP_EQ type)
  private generic-argument-clause ::= (OP_LANGLE generic-argument-list OP_RANGLE)
  private generic-argument-list ::= generic-argument (COMMA generic-argument)*
  private generic-argument ::= type

  // RULES:
  private any-keyword ::=
  KW_PND_AVAILABLE
  | KW_PND_COLORLITERAL
  | KW_PND_ELSE
  | KW_PND_ELSEIF
  | KW_PND_ENDIF
  | KW_PND_FILELITERAL
  | KW_PND_IF
  | KW_PND_IMAGELITERAL
  | KW_PND_KEYPATH
  | KW_PND_SELECTOR
  | KW_PND_SOURCELOCATION
  | KW_PND_UNAVAILABLE
  | KW_UPPER_ANY
  | KW_LOWER_ANY
  | KW_ASSOCIATEDTYPE
  | KW_AWAIT
  | KW_BORROWING
  | KW_BREAK
  | KW_CASE
  | KW_CLASS
  | KW_CONSUMING
  | KW_CONTINUE
  | KW_DEFAULT
  | KW_DEFER
  | KW_DEINIT
  | KW_DO
  | KW_ELSE
  | KW_ENUM
  | KW_EXTENSION
  | KW_FALLTHROUGH
  | KW_FALSE
  | KW_FILEPRIVATE
  | KW_FOR
  | KW_FUNC
  | KW_GUARD
  | KW_IF
  | KW_IMPORT
  | KW_IN
  | KW_INIT
  | KW_INOUT
  | KW_INTERNAL
  | KW_LET
  | KW_NIL
  | KW_NONISOLATED
  | KW_OPEN
  | KW_OPERATOR
  | KW_PRECEDENCEGROUP
  | KW_PRIVATE
  | KW_LOWER_PROTOCOL_DECL
  | KW_PUBLIC
  | KW_REPEAT
  | KW_RETURN
  | KW_LOWER_SELF
  | KW_UPPER_SELF
  | KW_STATIC
  | KW_STRUCT
  | KW_SUPER
  | KW_SWITCH
  | KW_SUBSCRIPT
  | KW_THROWS
  | KW_TRUE
  | KW_TRY
  | KW_TYPEALIAS
  | KW_VAR
  | KW_WHERE
  | KW_WHILE
  | KW_CATCH
  | KW_THROW
  | KW_RETHROWS
  | KW_ASSOCIATIVITY
  | KW_ASYNC
  | KW_CONVENIENCE
  | KW_DIDSET
  | KW_DYNAMIC
  | KW_FINAL
  | KW_GET
  | KW_INDIRECT
  | KW_INFIX
  | KW_LAZY
  | KW_LEFT
  | KW_MUTATING
  | KW_NONE
  | KW_NONMUTATING
  | KW_OPTIONAL
  | KW_OVERRIDE
  | KW_PACKAGE
  | KW_POSTFIX
  | KW_PRECEDENCE
  | KW_PREFIX
  | KW_UPPER_PROTOCOL
  | KW_REQUIRED
  | KW_RIGHT
  | KW_SET
  | KW_SOME
  | KW_UPPER_TYPE
  | KW_UNOWNED
  | KW_WEAK
  | KW_WILLSET

// balanced-token-punctuation can be any punctuation except (, ), [, ], {, or }
  private balanced-token-punctuation ::=
  KW_UNDERSCORE
  | OP_TYPE_CAST_BANG
  | OP_TYPE_CAST_OPT
  | OP_TYPE_CAST
  | OP_TYPE_CHECK
  | OP_OVERFLOW_BITSHIFT_LEFT_AND_ASSIGNMENT
  | OP_OVERFLOW_BITSHIFT_RIGHT_AND_ASSIGNMENT
  | OP_TRIPLE_LANGLE
  | OP_TRIPLE_RANGLE
  | OP_IDENTICAL
  | OP_NOT_IDENTICAL
  | OP_BITSHIFT_LEFT_AND_ASSIGNMENT
  | OP_BITSHIFT_RIGHT_AND_ASSIGNMENT
  | OP_OVERFLOW_BITSHIFT_LEFT
  | OP_OVERFLOW_BITSHIFT_RIGHT
  | OP_HALFOPEN_RANGE
  | OP_CLOSED_RANGE
  | OP_POINTWISE_EQ
  | OP_POINTWISE_NOT_EQ
  | OP_OVERFLOW_ADD_AND_ASSIGNMENT
  | OP_OVERFLOW_SUB_AND_ASSIGNMENT
  | OP_OVERFLOW_MULT_AND_ASSIGNMENT
  | OP_POINTWISE_BITWISE_AND_AND_ASSIGNMENT
  | OP_POINTWISE_BITWISE_OR_AND_ASSIGNMENT
  | OP_POINTWISE_BITWISE_XOR_AND_ASSIGNMENT
  | OP_POINTWISE_LESS_THAN_OR_EQ
  | OP_POINTWISE_GREATER_THAN_OR_EQ
  | OP_EQ
  | OP_LOGICAL_AND
  | OP_OVERFLOW_ADD
  | OP_OVERFLOW_SUB
  | OP_OVERFLOW_MULT
  | OP_BITWISE_AND_ASSIGNMENT
  | OP_BITWISE_OR_ASSIGNMENT
  | OP_BITWISE_XOR_ASSIGNMENT
  | OP_PATTERN_MATCH
  | OP_NOT_EQ
  | OP_BITSHIFT_LEFT
  | OP_BITSHIFT_RIGHT
  | OP_LESS_THAN_OR_EQ
  | OP_GREATER_THAN_OR_EQ
  | OP_POINTWISE_LESS_THAN
  | OP_POINTWISE_GREATER_THAN
  | OP_ADD_ASSIGNMENT
  | OP_SUB_ASSIGNMENT
  | OP_MULT_ASSIGNMENT
  | OP_DIV_ASSIGNMENT
  | OP_MODULO_ASSIGNMENT
  | OP_LOGICAL_OR
  | OP_POINTWISE_BITWISE_OR
  | OP_POINTWISE_BITWISE_XOR
  | OP_POINTWISE_NOT
  | OP_NIL_COALESCING
  | OP_TERNARY_CONDITIONAL
  | FWD_ARROW
  | AT_SYMBOL
  | POUND
  | COMMA
  | COLON
  | SEMICOLON
  | DOT
  | BACKSLASH
  | FWDSLASH
  | OP_ASSIGNMENT
  | OP_ADD
  | OP_SUB
  | OP_MULT
  | OP_MODULO
  | OP_NOT
  | OP_LANGLE
  | OP_RANGLE
  | OP_BITWISE_AND
  | OP_BITWISE_OR
  | OP_BITWISE_XOR
  | OP_BITWISE_NOT
  | OP_QUESTION

  // LEXICAL TOKEN DEFINITIONS:

  // GENERAL/SHARED ACROSS STATES
  token QUOTED_IDENTIFIER

  token STRING_INTERPOLATION_START
  token STRING_INTERPOLATION_END

  token SINGLELINE_STRING
  token STRING_TEXT
  token STRING_START
  token STRING_END
  token STRING_ESCAPED_SEQUENCE
  token MULTILINE_STRING
  token MULTILINE_STRING_TEXT
  token MULTILINE_STRING_START
  token MULTILINE_STRING_END
  token MULTILINE_STRING_ESCAPED_NEWLINE
  token MULTILINE_STRING_ESCAPED_SEQUENCE
  token EXTENDED_STRING_START
  token EXTENDED_STRING_END
  token EXTENDED_MULTILINE_STRING_START
  token EXTENDED_MULTILINE_STRING_END
  token SINGLELINE_COMMENT
  token COMMENT_TEXT
  token MULTILINE_COMMENT
  token MULTILINE_COMMENT_TEXT
  token MULTILINE_COMMENT_START
  token MULTILINE_COMMENT_END
  token REGEXP_LITERAL
  token REGEXP_LITERAL_START
  token REGEXP_LITERAL_END
  token REGEXP

  // KEYWORDS (Pound Sign #)
  token KW_PND_AVAILABLE
  token KW_PND_COLORLITERAL
  token KW_PND_ELSE
  token KW_PND_ELSEIF
  token KW_PND_ENDIF
  token KW_PND_FILELITERAL
  token KW_PND_IF
  token KW_PND_IMAGELITERAL
  token KW_PND_KEYPATH
  token KW_PND_SELECTOR
  token KW_PND_SOURCELOCATION
  token KW_PND_UNAVAILABLE

  // KEYWORDS reserved for DISTINCT USE
  token KW_UPPER_ANY
  token KW_LOWER_ANY
  token KW_ASSOCIATEDTYPE
  token KW_AWAIT
  token KW_BORROWING
  token KW_BREAK
  token KW_CASE
  token KW_CLASS
  token KW_CONSUMING
  token KW_CONTINUE
  token KW_DEFAULT
  token KW_DEFER
  token KW_DEINIT
  token KW_DO
  token KW_ELSE
  token KW_ENUM
  token KW_EXTENSION
  token KW_FALLTHROUGH
  token KW_FALSE
  token KW_FILEPRIVATE
  token KW_FOR
  token KW_FUNC
  token KW_GUARD
  token KW_IF
  token KW_IMPORT
  token KW_IN
  token KW_INIT
  token KW_INOUT
  token KW_INTERNAL
  token KW_LET
  token KW_NIL
  token KW_NONISOLATED
  token KW_OPEN
  token KW_OPERATOR
  token KW_PRECEDENCEGROUP
  token KW_PRIVATE
  token KW_LOWER_PROTOCOL_DECL
  token KW_PUBLIC
  token KW_REPEAT
  token KW_RETURN
  token KW_LOWER_SELF
  token KW_UPPER_SELF
  token KW_STATIC
  token KW_STRUCT
  token KW_SUPER
  token KW_SWITCH
  token KW_SUBSCRIPT
  token KW_THROWS
  token KW_TRUE
  token KW_TRY
  token KW_TYPEALIAS
  token KW_VAR
  token KW_WHERE
  token KW_WHILE

  // KEYWORDS reserved for DIFFERING USES depending on the context.
  token KW_CATCH
  token KW_THROW
  token KW_RETHROWS

  // KEYWORDS reserved ONLY IN PARTICULAR CONTEXTS. Outside the context in which they appear in the grammar, they can be used as identifiers.
token KW_ASSOCIATIVITY
token KW_ASYNC
token KW_CONVENIENCE
token KW_DIDSET
token KW_DYNAMIC
token KW_FINAL
token KW_GET
token KW_INDIRECT
token KW_INFIX
token KW_LAZY
token KW_LEFT
token KW_MUTATING
token KW_NONE
token KW_NONMUTATING
token KW_OPTIONAL
token KW_OVERRIDE
token KW_PACKAGE
token KW_POSTFIX
token KW_PRECEDENCE
token KW_PREFIX
token KW_UPPER_PROTOCOL
token KW_REQUIRED
token KW_RIGHT
token KW_SET
token KW_SOME
token KW_UPPER_TYPE
token KW_UNOWNED
token KW_WEAK
token KW_WILLSET

  // KEYWORDS reserved for PATTERNS
  token KW_UNDERSCORE

  // FLOATING POINT LITERALS
  token FLOATING_POINT_LITERAL
  token HEX_FLOATING_POINT_LITERAL
  token DECIMAL_FLOATING_POINT_LITERAL

  // INTEGER LITERALS
  token BINARY_LITERAL
  token OCTAL_LITERAL
  token HEX_LITERAL
  token DECIMAL_LITERAL

  // OPERATORS AND PUNCTUATION (Fixed String Literals)
  token OP_TYPE_CAST_BANG
  token OP_TYPE_CAST_OPT
  token OP_TYPE_CAST
  token OP_TYPE_CHECK
  token OP_OVERFLOW_BITSHIFT_LEFT_AND_ASSIGNMENT
  token OP_OVERFLOW_BITSHIFT_RIGHT_AND_ASSIGNMENT
  token OP_TRIPLE_LANGLE
  token OP_TRIPLE_RANGLE
  token OP_IDENTICAL
  token OP_NOT_IDENTICAL
  token OP_BITSHIFT_LEFT_AND_ASSIGNMENT
  token OP_BITSHIFT_RIGHT_AND_ASSIGNMENT
  token OP_OVERFLOW_BITSHIFT_LEFT
  token OP_OVERFLOW_BITSHIFT_RIGHT
  token OP_HALFOPEN_RANGE
  token OP_CLOSED_RANGE
  token OP_POINTWISE_EQ
  token OP_POINTWISE_NOT_EQ
  token OP_OVERFLOW_ADD_AND_ASSIGNMENT
  token OP_OVERFLOW_SUB_AND_ASSIGNMENT
  token OP_OVERFLOW_MULT_AND_ASSIGNMENT
  token OP_POINTWISE_BITWISE_AND_AND_ASSIGNMENT
  token OP_POINTWISE_BITWISE_OR_AND_ASSIGNMENT
  token OP_POINTWISE_BITWISE_XOR_AND_ASSIGNMENT
  token OP_POINTWISE_LESS_THAN_OR_EQ
  token OP_POINTWISE_GREATER_THAN_OR_EQ
  token OP_EQ
  token OP_LOGICAL_AND
  token OP_OVERFLOW_ADD
  token OP_OVERFLOW_SUB
  token OP_OVERFLOW_MULT
  token OP_BITWISE_AND_ASSIGNMENT
  token OP_BITWISE_OR_ASSIGNMENT
  token OP_BITWISE_XOR_ASSIGNMENT
  token OP_PATTERN_MATCH
  token OP_NOT_EQ
  token OP_BITSHIFT_LEFT
  token OP_BITSHIFT_RIGHT
  token OP_LESS_THAN_OR_EQ
  token OP_GREATER_THAN_OR_EQ
  token OP_POINTWISE_LESS_THAN
  token OP_POINTWISE_GREATER_THAN
  token OP_ADD_ASSIGNMENT
  token OP_SUB_ASSIGNMENT
  token OP_MULT_ASSIGNMENT
  token OP_DIV_ASSIGNMENT
  token OP_MODULO_ASSIGNMENT
  token OP_LOGICAL_OR
  token OP_POINTWISE_BITWISE_OR
  token OP_POINTWISE_BITWISE_XOR
  token OP_POINTWISE_NOT
  token OP_NIL_COALESCING
  token OP_TERNARY_CONDITIONAL
  token FWD_ARROW

  // SPECIAL: RPAREN
  token STRING_INTERPOLATION_END
  token RPAREN

  // FIXIE SINGLE-CHAR PUNCTUATION:
  token LPAREN
  token AT_SYMBOL
  token POUND
  token LBRACE
  token RBRACE
  token LBRACKET
  token RBRACKET
  token COMMA
  token COLON
  token SEMICOLON
  token DOT
  token BACKSLASH

  // FIXIE SINGLE-CHARs that CAN ALSO START CUSTOM OPERATORS
  token FWDSLASH
  token OP_ASSIGNMENT
  token OP_ADD
  token OP_SUB
  token OP_MULT
  token OP_MODULO
  token OP_NOT
  token OP_LANGLE
  token OP_RANGLE
  token OP_BITWISE_AND
  token OP_BITWISE_OR
  token OP_BITWISE_XOR
  token OP_BITWISE_NOT
  token OP_QUESTION

  // IMPLICIT PARAMETER NAMES, PROPERTY WRAPPER PROJECTIONS
  token IMPLICIT_PARAMETER_NAME
  token PROPERTY_WRAPPER_PROJECTION

  // CUSTOM OPERATORS
  token DOT_OPERATOR
  token OPERATOR
  token IDENTIFIER

  // TOKENS: REGEX LITERALS (FUTURE)

  // END FILE Swift.bnf
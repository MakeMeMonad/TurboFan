/*
  Swift Language Grammar for CLion Plugin
  BEGIN FILE Swift.bnf
  References and Links:
  https://docs.swift.org/swift-book/documentation/the-swift-programming-language/aboutthelanguagereference/
  https://docs.swift.org/swift-book/documentation/the-swift-programming-language/lexicalstructure/
  https://docs.swift.org/swift-book/documentation/the-swift-programming-language/summaryofthegrammar/
  Above references are:
    Copyright © 2014–2023 Apple Inc. and the Swift project authors. All rights reserved.
    This document is made available under a Creative Commons Attribution 4.0 International (CC BY 4.0) License.
    Swift and the Swift logo are trademarks of Apple Inc.

  https://github.com/JetBrains/Grammar-Kit
  Above reference is:
    Pertinent License Info goes here...

*/

  {
  // Generates methods like `getKwIf()` etc. on composite elements
  generatePsi=true
  generateTokens=true
  generateTokenAccessors=true
  parserClass="com.makememonad.turbofan.language.swift.parser.SwiftParser"
  parserUtilClass="com.makememonad.turbofan.language.swift.parser.SwiftParserUtil"
  // implements="com.intellij.psi.tree.IElementType"
  // Common base for PSI elements
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  // Where IElementType constants go
  elementTypeHolderClass="com.makememonad.turbofan.language.swift.psi.SwiftTypes"
  // Base for element types
  elementTypeClass="com.intellij.psi.tree.IElementType"
  // Base for token types (often same as elementTypeClass)
  tokenTypeClass="com.intellij.psi.tree.IElementType"
  // e.g., Swift<RuleName> for interfaces
  psiClassPrefix="Swift"
  // e.g., SwiftImpl<RuleName> for implementations
  psiImplClassSuffix="SwiftImpl"
  // Where PSI interfaces go
  psiPackage="com.makememonad.turbofan.language.swift.psi"
  // Where PSI impls go
  psiImplPackage="com.makememonad.turbofan.language.swift.psi.impl"
  // For custom methods on PSI nodes
  psiImplUtilClass="com.makememonad.turbofan.language.swift.psi.impl.SwiftPsiImplUtil"
  // elementTypeFactory()= com.makememonad.turbofan.language.swift.psi.stubs.SwiftStubElementTypeFactory.create
  }
  // GRAMMAR RULE DEFINITIONS:
  // RULES: LEXICAL STRUCTURE (Mainly handled in the JFlex with tokens redefined below...
  swiftFile ::= top-level-declaration?
  top-level-declaration ::= statements
  identifier-list ::= IDENTIFIER (COMMA IDENTIFIER)*
  literal ::= numeric-literal | string-literal | regular-expression-literal | boolean-literal | nil-literal
  numeric-literal ::= OP_SUB? integer-literal | OP_SUB? floating-point-literal
  boolean-literal ::= KW_TRUE | KW_FALSE
  nil-literal ::= KW_NIL
  integer-literal ::= BINARY_LITERAL | OCTAL_LITERAL | DECIMAL_LITERAL | HEXADECIMAL_LITERAL
  floating-point-literal ::= DECIMAL_FLOATING_POINT_LITERAL | HEX_FLOATING_POINT_LITERAL

  // RULES: STRING LITERALS
  string-literal ::= static-string-literal | interpolated-string-literal
  //string-literal-opening-delimiter → extended-string-literal-delimiter? "
  //string-literal-closing-delimiter → " extended-string-literal-delimiter?
  static-string-literal ::= (STRING_START STRING_TEXT* STRING_END) | (MULTILINE_STRING_START MULTILINE_STRING_TEXT* MULTILINE_STRING_END)
  //multiline-string-literal-opening-delimiter → extended-string-literal-delimiter? """
  //multiline-string-literal-closing-delimiter → """ extended-string-literal-delimiter?
  //extended-string-literal-delimiter → # extended-string-literal-delimiter?
  interpolated-string-literal ::= (STRING_START interpolated-text? STRING_END) | (MULTILINE_STRING_START multiline-interpolated-text? MULTILINE_STRING_END)
  interpolated-text ::= interpolated-text-item interpolated-text*
  interpolated-text-item ::= (STRING_INTERPOLATION_START expression STRING_INTERPOLATION_END) | STRING_TEXT
  multiline-interpolated-text ::= multiline-interpolated-text-item multiline-interpolated-text?
  multiline-interpolated-text-item ::= (STRING_INTERPOLATION_START expression STRING_INTERPOLATION_END) | MULTILINE_STRING_TEXT

  // RULES: REGEX LITERALS
  regular-expression-literal ::= REGEXP_LITERAL
  //regular-expression-literal-opening-delimiter → extended-regular-expression-literal-delimiter? /
  //regular-expression-literal-closing-delimiter → / extended-regular-expression-literal-delimiter?
  //extended-regular-expression-literal-delimiter → # extended-regular-expression-literal-delimiter?

  // RULES: OPERATOR LITERALS
  infix-operator ::= OPERATOR
  prefix-operator ::= OPERATOR
  postfix-operator ::= OPERATOR

  // RULES: TYPES
  // Type Intermediates
  type ::= (LPAREN? base-type RPAREN?) (optional-type-suffix | implicitly-unwrapped-optional-type-suffix | metatype-type-suffix)?
  base-type ::= function-type | array-type | dictionary-type | type-identifier | tuple-type | protocol-composition-type | opaque-type | KW_UPPER_ANY | KW_UPPER_SELF
  optional-type-suffix ::= OP_QUESTION
  implicitly-unwrapped-optional-type-suffix ::= OP_NOT
  metatype-type-suffix ::= (DOT KW_UPPER_TYPE | DOT KW_UPPER_PROTOCOL)
  type-annotation ::= COLON attributes? KW_INOUT? type
  type-identifier ::= type-name generic-argument-clause? (DOT type-name generic-argument-clause?)*
  type-name ::= IDENTIFIER
  // Tuple Types
  tuple-type ::= LPAREN (tuple-type-element (COMMA tuple-type-element)+)? RPAREN
  tuple-type-element ::= IDENTIFIER type-annotation | type
  // Function Types
  function-type ::= attributes? function-type-argument-clause KW_ASYNC? throws-clause? KW_FWD_ARROW type
  function-type-argument-clause ::= LPAREN (function-type-argument-list KW_ELLIPSIS?)? RPAREN
  function-type-argument-list ::= function-type-argument (COMMA function-type-argument)*
  function-type-argument ::= attributes? KW_INOUT? type | IDENTIFIER type-annotation
  throws-clause ::= KW_THROWS (LPAREN type RPAREN)?
  // Array Types
  array-type ::= LBRACKET type RBRACKET
  // Dict Types
  dictionary-type ::= LBRACKET type COLON type RBRACKET
  // Opt Types
  protocol-composition-type ::= (type-identifier (OP_BITWISE_AND type-identifier)+)
  opaque-type ::= (KW_SOME type)
  boxed-protocol-type ::= (KW_LOWER_ANY type)
  type-inheritance-clause ::= COLON type-inheritance-list
  type-inheritance-list ::= attributes? type-identifier (COMMA attributes? type-identifier)*
  // RULES: EXPRESSIONS
  expression ::= try-operator? KW_AWAIT? prefix-expression infix-expressions?
  prefix-expression ::= prefix-operator? postfix-expression | in-out-expression
  in-out-expression ::= (OP_BITWISE_AND primary-expression)
  try-operator ::= KW_TRY (OP_QUESTION | OP_NOT)?
  infix-expression ::= infix-operator prefix-expression | OP_ASSIGNMENT try-operator? KW_AWAIT? prefix-expression | conditional-operator try-operator? KW_AWAIT? prefix-expression | type-casting-operator
  infix-expressions ::= infix-expression (infix-expression)*
  conditional-operator ::= (OP_QUESTION expression COLON)
  type-casting-operator ::= (OP_TYPE_CHECK | OP_TYPE_CAST (OP_QUESTION | OP_NOT)?) type
  primary-expression ::= IDENTIFIER generic-argument-clause? | literal-expression | self-expression | superclass-expression | conditional-expression | closure-expression | parenthesized-expression | tuple-expression | implicit-member-expression | wildcard-expression | macro-expansion-expression | key-path-expression | selector-expression | key-path-string-expression
  literal-expression ::= literal | array-literal | dictionary-literal | playground-literal
  array-literal ::= (LBRACKET array-literal-items? COMMA? RBRACKET)
  array-literal-items ::= expression (COMMA expression)*
  dictionary-literal ::= (LBRACKET dictionary-literal-items COMMA? RBRACKET) | (LBRACKET COLON RBRACKET)
  dictionary-literal-items ::= dictionary-literal-item (COMMA dictionary-literal-item)*
  dictionary-literal-item ::= (expression COLON expression)
  playground-literal ::= (KW_PND_COLORLITERAL (LPAREN (("red" COLON expression) COMMA) (("green" COLON expression) COMMA) (("blue" COLON expression) COMMA) (("alpha" COLON expression) COMMA?) RPAREN)) | (KW_PND_FILELITERAL | KW_PND_IMAGELITERAL) (LPAREN "resourceName" COLON expression RPAREN)
  self-expression ::= KW_LOWER_SELF | self-method-expression | self-subscript-expression | self-initializer-expression
  self-method-expression ::= (KW_LOWER_SELF DOT IDENTIFIER)
  self-subscript-expression ::= KW_LOWER_SELF (LBRACKET function-call-argument-list RBRACKET)
  self-initializer-expression ::= (KW_LOWER_SELF DOT KW_INIT)
  superclass-expression ::= superclass-method-expression | superclass-subscript-expression | superclass-initializer-expression
  superclass-method-expression ::= (KW_SUPER DOT IDENTIFIER)
  superclass-subscript-expression ::= KW_SUPER LBRACKET function-call-argument-list RBRACKET
  superclass-initializer-expression ::= KW_SUPER DOT KW_INIT
  conditional-expression ::= if-expression | switch-expression
  if-expression ::= KW_IF condition-list (LBRACE statement RBRACE) if-expression-tail
  if-expression-tail ::= KW_ELSE (if-expression | LBRACE statement RBRACE)
  switch-expression ::= KW_SWITCH expression (LBRACE switch-expression-cases RBRACE)
  switch-expression-cases ::= switch-expression-case (switch-expression-case)*
  switch-expression-case ::= case-label statement | default-label statement
  closure-expression ::= (LBRACE attributes? closure-signature? statements? RBRACE)
  closure-signature ::= capture-list? closure-parameter-clause async? throws-clause? function-result? KW_IN | capture-list KW_IN
  closure-parameter-clause ::= LPAREN (closure-parameter-list)? RPAREN | identifier-list
  closure-parameter-list ::= closure-parameter (COMMA closure-parameter)*
  closure-parameter ::= IDENTIFIER type-annotation? | IDENTIFIER type-annotation ELLIPSIS
  capture-list ::= (LBRACKET capture-list-items RBRACKET)
  capture-list-items ::= capture-list-item (COMMA capture-list-item)*
  capture-list-item ::= capture-specifier? IDENTIFIER | capture-specifier? IDENTIFIER OP_ASSIGNMENT expression | capture-specifier? self-expression
  capture-specifier ::= KW_WEAK | KW_UNOWNED | KW_UNOWNED LPAREN KW_SAFE RPAREN | KW_UNOWNED LPAREN KW_UNSAFE RPAREN
  implicit-member-expression ::= DOT IDENTIFIER | DOT IDENTIFIER DOT postfix-expression
  parenthesized-expression ::= (LPAREN expression RPAREN)
  tuple-expression ::= (LPAREN (tuple-element COMMA tuple-element-list)? RPAREN)
  tuple-element-list ::= tuple-element (COMMA tuple-element)*
  tuple-element ::= expression | (IDENTIFIER COLON expression)
  wildcard-expression ::= OP_UNDERSCORE
  macro-expansion-expression ::= POUND IDENTIFIER generic-argument-clause? function-call-argument-clause? trailing-closures?
  key-path-expression ::= (BACKSLASH type? DOT key-path-components)
  key-path-components ::= key-path-component (DOT key-path-component)*
  key-path-component ::= IDENTIFIER key-path-postfixes? | key-path-postfixes
  key-path-postfixes ::= key-path-postfix (key-path-postfix)*
  key-path-postfix ::= OP_QUESTION | OP_NOT | KW_LOWER_SELF | (LBRACKET function-call-argument-list RBRACKET)
  selector-expression ::= KW_PND_SELECTOR (LPAREN expression RPAREN) | KW_PND_SELECTOR (LPAREN "getter" COLON expression RPAREN) | KW_PND_SELECTOR (LPAREN "setter" COLON expression RPAREN)
  key-path-string-expression ::= KW_PND_KEYPATH (LPAREN expression RPAREN)
  postfix-expression ::= base-postfix-expression (postfix-operator | function-call-expression | initializer-expression | explicit-member-expression | postfix-self-expression | subscript-expression | forced-value-expression | optional-chaining-expression)?
  base-postfix-expression ::= primary-expression
  function-call-expression ::= (function-call-argument-clause | (function-call-argument-clause? trailing-closures))
  function-call-argument-clause ::= (LPAREN function-call-argument-list? RPAREN)
  function-call-argument-list ::= function-call-argument (COMMA function-call-argument)*
  function-call-argument ::= (IDENTIFIER COLON )? (expression | OPERATOR)
  trailing-closures ::= closure-expression (IDENTIFIER COLON closure-expression)*
  initializer-expression ::= (DOT KW_INIT) (LPAREN argument-names RPAREN)?
  explicit-member-expression ::= (DOT DECIMAL_LITERAL | DOT IDENTIFIER (LPAREN argument-names RPAREN | generic-argument-clause?) | conditional-compilation-block)
  argument-names ::= argument-name (argument-name)*
  argument-name ::= (IDENTIFIER COLON)
  postfix-self-expression ::= (DOT KW_LOWER_SELF)
  subscript-expression ::= (LBRACKET function-call-argument-list RBRACKET)
  forced-value-expression ::= (OP_NOT)
  optional-chaining-expression ::= (OP_QUESTION)

  // RULES: STATEMENTS
  statement ::= (expression | declaration | loop-statement | branch-statement | labeled-statement | control-transfer-statement | defer-statement | do-statement) SEMICOLON? | compiler-control-statement
  statements ::= statement (statement)*
  loop-statement ::= for-in-statement | while-statement | repeat-while-statement
  for-in-statement ::= KW_FOR KW_CASE? pattern KW_IN expression where-clause? code-block
  while-statement ::= KW_WHILE condition-list code-block
  condition-list ::= condition (COMMA condition)*
  condition ::= expression | availability-condition | case-condition | optional-binding-condition
  case-condition ::= KW_CASE pattern initializer
  optional-binding-condition ::= (KW_LET | KW_VAR) pattern initializer?
  repeat-while-statement ::= KW_REPEAT code-block KW_WHILE expression
  branch-statement ::= if-statement | guard-statement | switch-statement
  if-statement ::= KW_IF condition-list code-block else-clause?
  else-clause ::= KW_ELSE (code-block | if-statement)
  guard-statement ::= KW_GUARD condition-list KW_ELSE code-block
  switch-statement ::= switch expression (LBRACE switch-cases? RBRACE)
  switch-cases ::= switch-case (switch-case)*
  switch-case ::= case-label statements | default-label statements | conditional-switch-case
  case-label ::= attributes? KW_CASE case-item-list COLON
  case-item-list ::= pattern where-clause? (COMMA pattern where-clause?)*
  default-label ::= attributes? (KW_DEFAULT COLON)
  where-clause ::= (KW_WHERE where-expression)
  where-expression ::= expression
  conditional-switch-case ::= switch-if-directive-clause switch-elseif-directive-clauses? switch-else-directive-clause? endif-directive
  switch-if-directive-clause ::= if-directive compilation-condition switch-cases?
  switch-elseif-directive-clauses ::= elseif-directive-clause (elseif-directive-clause)*
  switch-elseif-directive-clause ::= elseif-directive compilation-condition switch-cases?
  switch-else-directive-clause ::= else-directive switch-cases?
  labeled-statement ::= statement-label (loop-statement | if-statement | switch-statement | do-statement)
  statement-label ::= (label-name COLON)
  label-name ::= IDENTIFIER
  control-transfer-statement ::= break-statement | continue-statement | fallthrough-statement | return-statement | throw-statement
  break-statement ::= KW_BREAK label-name?
  continue-statement ::= KW_CONTINUE label-name?
  fallthrough-statement ::= KW_FALLTHROUGH
  return-statement ::= return expression?
  throw-statement ::= throw expression
  defer-statement ::= KW_DEFER code-block
  do-statement ::= KW_DO throws-clause? code-block catch-clauses?
  catch-clauses ::= catch-clause (catch-clause)*
  catch-clause ::= KW_CATCH catch-pattern-list? code-block
  catch-pattern-list ::= catch-pattern (COMMA catch-pattern)*
  catch-pattern ::= (pattern where-clause?)
  compiler-control-statement ::= conditional-compilation-block | line-control-statement
  conditional-compilation-block ::= if-directive-clause elseif-directive-clauses? else-directive-clause? endif-directive
  if-directive-clause ::= if-directive compilation-condition statements?
  elseif-directive-clauses ::= elseif-directive-clause (elseif-directive-clause)*
  elseif-directive-clause ::= elseif-directive compilation-condition statements?
  else-directive-clause ::= else-directive statements?
  if-directive ::= KW_PND_IF
  elseif-directive ::= KW_PND_ELSEIF
  else-directive ::= KW_PND_ELSE
  endif-directive ::= KW_PND_ENDIF
  compilation-condition ::= base-compilation-condition | (LPAREN base-compilation-condition RPAREN) | (base-compilation-condition (OP_LOGICAL_AND | OP_LOGICAL_OR) base-compilation-condition)
  base-compilation-condition ::= platform-condition | IDENTIFIER | boolean-literal | (OP_NOT compilation-condition)
  platform-condition ::= "os" (LPAREN operating-system RPAREN) | "arch" (LPAREN architecture RPAREN) | "swift" (LPAREN (OP_GREATER_THAN_OR_EQ | OP_LANGLE) swift-version RPAREN) | "compiler" (LPAREN (OP_LESS_THAN_OR_EQ | OP_LANGLE) swift-version RPAREN) | "canImport" (LPAREN import-path RPAREN) | "targetEnvironment" (LPAREN environment RPAREN)
  operating-system ::= "macOS" | "iOS" | "watchOS" | "tvOS" | "visionOS" | "Linux" | "Windows"
  architecture ::= "i386" | "x86_64" | "arm" | "arm64"
  swift-version ::= DECIMAL_LITERAL (DOT DECIMAL_LITERAL)*
  environment ::= "simulator" | "macCatalyst"
  line-control-statement ::= KW_PND_SOURCELOCATION (LPAREN ("file" COLON file-path COMMA "line" COLON line-number)? RPAREN)
  line-number ::= DECIMAL_LITERAL
  file-path ::= static-string-literal
  availability-condition ::= KW_PND_AVAILABLE (LPAREN availability-arguments RPAREN) | KW_PND_UNAVAILABLE (LPAREN availability-arguments RPAREN)
  availability-arguments ::= availability-argument (COMMA availability-argument)*
  availability-argument ::= platform-name (DECIMAL_LITERAL | DECIMAL_FLOATING_POINT_LITERAL) | OP_MULT
  platform-name ::= "iOS" | "iOSApplicationExtension" | "macOS" | "macOSApplicationExtension" | "macCatalyst" | "macCatalystApplicationExtension" | "watchOS" | "watchOSApplicationExtension" | "tvOS" | "tvOSApplicationExtension" | "visionOS" | "visionOSApplicationExtension"
  // RULES: DECLARATIONS
  declaration ::= import-declaration | constant-declaration | variable-declaration | typealias-declaration | function-declaration | enum-declaration | struct-declaration | class-declaration | actor-declaration | protocol-declaration | initializer-declaration | deinitializer-declaration | extension-declaration | subscript-declaration | operator-declaration | precedence-group-declaration
  code-block ::= (LBRACE statements? RBRACE)
  import-declaration ::= attributes? KW_IMPORT import-kind? import-path
  import-kind ::= KW_TYPEALIAS | KW_STRUCT | KW_CLASS | KW_ENUM | KW_LOWER_PROTOCOL_DECL | KW_LET | KW_VAR | KW_FUNC
  import-path ::= IDENTIFIER (DOT import-path)?
  constant-declaration ::= attributes? declaration-modifiers? KW_LET pattern-initializer-list
  pattern-initializer-list ::= pattern-initializer (COMMA pattern-initializer)*
  pattern-initializer ::= (pattern initializer?)
  initializer ::= OP_ASSIGNMENT expression
  variable-declaration ::= variable-declaration-head (pattern-initializer-list | variable-name (type-annotation (code-block | getter-setter-block | getter-setter-keyword-block ) | initializer willSet-didSet-block | type-annotation initializer? willSet-didSet-block))
  variable-declaration-head ::= attributes? declaration-modifiers? KW_VAR
  variable-name ::= IDENTIFIER
  getter-setter-block ::= code-block | (LBRACE getter-clause setter-clause? RBRACE) | (LBRACE setter-clause getter-clause RBRACE)
  getter-clause ::= attributes? mutation-modifier? KW_GET code-block
  setter-clause ::= attributes? mutation-modifier? KW_SET setter-name? code-block
  setter-name ::= (LPAREN IDENTIFIER RPAREN)
  getter-setter-keyword-block ::= (LBRACE getter-keyword-clause setter-keyword-clause? RBRACE) | (LBRACE setter-keyword-clause getter-keyword-clause RBRACE)
  getter-keyword-clause ::= attributes? mutation-modifier? KW_GET
  setter-keyword-clause ::= attributes? mutation-modifier? KW_SET
  willSet-didSet-block ::= (LBRACE willSet-clause didSet-clause? RBRACE) | (LBRACE didSet-clause willSet-clause? RBRACE)
  willSet-clause ::= attributes? KW_WILLSET setter-name? code-block
  didSet-clause ::= attributes? KW_DIDSET setter-name? code-block
  typealias-declaration ::= attributes? access-level-modifier? KW_TYPEALIAS typealias-name generic-parameter-clause? typealias-assignment
  typealias-name ::= IDENTIFIER
  typealias-assignment ::= OP_ASSIGNMENT type
  function-declaration ::= function-head function-name generic-parameter-clause? function-signature generic-where-clause?  code-block?
  function-head ::= attributes? declaration-modifiers? KW_FUNC
  function-name ::= IDENTIFIER | OPERATOR
  function-signature ::= parameter-clause KW_ASYNC? (KW_RETHROWS | throws-clause?) function-result?
  function-result ::= (KW_FWD_ARROW attributes? type)
  parameter-clause ::= (LPAREN parameter-list? RPAREN)
  parameter-list ::= parameter (COMMA parameter)*
  parameter ::= external-parameter-name? IDENTIFIER parameter-type-annotation (KW_ELLIPSIS | default-argument-clause?)?
  external-parameter-name ::= IDENTIFIER
  parameter-type-annotation ::= COLON attributes? parameter-modifier? type
  parameter-modifier ::= KW_INOUT | KW_BORROWING | KW_CONSUMING
  default-argument-clause ::= OP_ASSIGNMENT expression
  enum-declaration ::= attributes? access-level-modifier? (union-style-enum | raw-value-style-enum)
  union-style-enum ::= (KW_INDIRECT? KW_ENUM enum-name) generic-parameter-clause? type-inheritance-clause? generic-where-clause? (LBRACE union-style-enum-members? RBRACE)
  union-style-enum-members ::= union-style-enum-member (union-style-enum-member)*
  union-style-enum-member ::= declaration | union-style-enum-case-clause | compiler-control-statement
  union-style-enum-case-clause ::= attributes? KW_INDIRECT? KW_CASE union-style-enum-case-list
  union-style-enum-case-list ::= union-style-enum-case (COMMA union-style-enum-case)*
  union-style-enum-case ::= enum-case-name tuple-type?
  enum-name ::= IDENTIFIER
  enum-case-name ::= IDENTIFIER
  raw-value-style-enum ::= KW_ENUM enum-name generic-parameter-clause? type-inheritance-clause generic-where-clause? (LBRACE raw-value-style-enum-members RBRACE)
  raw-value-style-enum-members ::= raw-value-style-enum-member (raw-value-style-enum-member)*
  raw-value-style-enum-member ::= declaration | raw-value-style-enum-case-clause | compiler-control-statement
  raw-value-style-enum-case-clause ::= attributes? KW_CASE raw-value-style-enum-case-list
  raw-value-style-enum-case-list ::= raw-value-style-enum-case (COMMA raw-value-style-enum-case)*
  raw-value-style-enum-case ::= enum-case-name raw-value-assignment?
  raw-value-assignment ::= (OP_ASSIGNMENT raw-value-literal)
  raw-value-literal ::= numeric-literal | static-string-literal | boolean-literal
  struct-declaration ::= attributes? access-level-modifier? KW_STRUCT IDENTIFIER generic-parameter-clause? type-inheritance-clause? generic-where-clause? struct-body
  struct-body ::= (LBRACE struct-members? RBRACE)
  struct-members ::= struct-member (struct-member)*
  struct-member ::= declaration | compiler-control-statement
  class-declaration ::= attributes? class-access KW_CLASS IDENTIFIER generic-parameter-clause? type-inheritance-clause? generic-where-clause? class-body
  class-access ::= (KW_FINAL access-level-modifier?) | (access-level-modifier? KW_FINAL?)
  class-body ::= (LBRACE class-members? RBRACE)
  class-members ::= class-member (class-member)*
  class-member ::= declaration | compiler-control-statement
  actor-declaration ::= attributes? access-level-modifier? KW_ACTOR IDENTIFIER generic-parameter-clause? type-inheritance-clause? generic-where-clause? actor-body
  actor-body ::= (LBRACE actor-members? RBRACE)
  actor-members ::= actor-member (actor-member)*
  actor-member ::= declaration | compiler-control-statement
  protocol-declaration ::= attributes? access-level-modifier? KW_LOWER_PROTOCOL_DECL IDENTIFIER type-inheritance-clause? generic-where-clause? protocol-body
  protocol-body ::= (LBRACE protocol-members? RBRACE)
  protocol-members ::= protocol-member (protocol-member)*
  protocol-member ::= protocol-member-declaration | compiler-control-statement
  protocol-member-declaration ::=
  // protocol-property-declaration |
  protocol-method-declaration | protocol-initializer-declaration | protocol-subscript-declaration | protocol-associated-type-declaration | typealias-declaration | variable-declaration-head variable-name type-annotation getter-setter-keyword-block

  protocol-method-declaration ::= function-head function-name generic-parameter-clause? function-signature generic-where-clause?
  protocol-initializer-declaration ::= initializer-head generic-parameter-clause? parameter-clause throws-clause? generic-where-clause? | initializer-head generic-parameter-clause? parameter-clause KW_RETHROWS generic-where-clause?
  protocol-subscript-declaration ::= subscript-head subscript-result generic-where-clause? getter-setter-keyword-block
  protocol-associated-type-declaration ::= attributes? access-level-modifier? KW_ASSOCIATEDTYPE typealias-name type-inheritance-clause? typealias-assignment? generic-where-clause?
  initializer-declaration ::= initializer-head generic-parameter-clause? parameter-clause KW_ASYNC? (KW_RETHROWS | throws-clause?) generic-where-clause? code-block
  initializer-head ::= (attributes? declaration-modifiers? (KW_INIT (OP_QUESTION | OP_NOT)? ))
  deinitializer-declaration ::= (attributes? KW_DEINIT code-block)
  extension-declaration ::= attributes? access-level-modifier? KW_EXTENSION type-identifier type-inheritance-clause? generic-where-clause? extension-body
  extension-body ::= (LBRACE extension-members? RBRACE)
  extension-members ::= extension-member (extension-member)*
  extension-member ::= declaration | compiler-control-statement
  subscript-declaration ::= subscript-head subscript-result generic-where-clause? (code-block | getter-setter-block | getter-setter-keyword-block)
  subscript-head ::= attributes? declaration-modifiers? KW_SUBSCRIPT generic-parameter-clause? parameter-clause
  subscript-result ::= (KW_FWD_ARROW attributes? type)

  macro-declaration ::= macro-head IDENTIFIER generic-parameter-clause? macro-signature macro-definition? generic-where-clause
  macro-head ::= (attributes? declaration-modifiers? KW_MACRO)
  macro-signature ::= (parameter-clause (KW_FWD_ARROW type)?)
  macro-definition ::= (OP_ASSIGNMENT expression)

  operator-declaration ::= prefix-operator-declaration | postfix-operator-declaration | infix-operator-declaration
  prefix-operator-declaration ::= KW_PREFIX KW_OPERATOR OPERATOR
  postfix-operator-declaration ::= KW_POSTFIX KW_OPERATOR OPERATOR
  infix-operator-declaration ::= KW_INFIX KW_OPERATOR OPERATOR infix-operator-group?
  infix-operator-group ::= (COLON precedence-group-name)
  precedence-group-declaration ::= KW_PRECEDENCEGROUP precedence-group-name (LBRACE precedence-group-attributes? RBRACE)
  precedence-group-attributes ::= precedence-group-attribute (precedence-group-attribute)*
  precedence-group-attribute ::= precedence-group-relation | precedence-group-assignment | precedence-group-associativity
  precedence-group-relation ::= (KW_HIGHER_THAN COLON |  KW_LOWER_THAN COLON) precedence-group-names
  precedence-group-assignment ::= KW_ASSIGNMENT COLON boolean-literal
  precedence-group-associativity ::= (KW_ASSOCIATIVITY COLON ("left" | "right" | "none"))
  precedence-group-names ::= precedence-group-name (COMMA precedence-group-name)*
  precedence-group-name ::= IDENTIFIER
  declaration-modifier ::= KW_CLASS | KW_CONVENIENCE | KW_DYNAMIC | KW_FINAL | KW_INFIX | KW_LAZY | KW_OPTIONAL | KW_OVERRIDE | KW_POSTFIX | KW_PREFIX | KW_REQUIRED | KW_STATIC | KW_UNOWNED (LPAREN (KW_SAFE | KW_UNSAFE) RPAREN)? | KW_WEAK | access-level-modifier | mutation-modifier | KW_NONISOLATED
  declaration-modifiers ::= declaration-modifier (declaration-modifier)*
  access-level-modifier ::= KW_PRIVATE (LPAREN KW_SET RPAREN)? | KW_FILEPRIVATE (LPAREN KW_SET RPAREN)? | KW_INTERNAL (LPAREN KW_SET RPAREN)? | KW_PACKAGE (LPAREN KW_SET RPAREN)? | KW_PUBLIC (LPAREN KW_SET RPAREN)? | KW_OPEN (LPAREN KW_SET RPAREN)?
  mutation-modifier ::= KW_MUTATING | KW_NONMUTATING

  // RULES: ATTRIBUTES
  attribute ::= (OP_AT IDENTIFIER attribute-argument-clause?)
  attribute-argument-clause ::= (LPAREN balanced-tokens? RPAREN)
  attributes ::= attribute (attribute)*
  balanced-tokens ::= balanced-token (balanced-token)*
  balanced-token ::= base-balanced-token | ((LPAREN | LBRACKET | LBRACE) base-balanced-token? (RPAREN | RBRACKET | RBRACE))
  base-balanced-token ::= IDENTIFIER | any-keyword | literal | OPERATOR | balanced-token-punctuation

  // RULES: PATTERNS
  pattern ::= base-pattern type-casting-suffix?
  | type-checking-pattern
  base-pattern ::=
  ((wildcard-pattern | identifier-pattern| tuple-pattern) type-annotation?)
    | value-binding-pattern
    | enum-case-pattern
    | optional-pattern
    | expression-pattern
  type-casting-suffix ::= (OP_TYPE_CAST type)
  type-checking-pattern ::= (OP_TYPE_CHECK type)
  wildcard-pattern ::= KW_UNDERSCORE
  identifier-pattern ::= IDENTIFIER
  value-binding-pattern ::= (KW_VAR | KW_LET) pattern
  tuple-pattern ::= (LPAREN tuple-pattern-element-list? RPAREN)
  tuple-pattern-element-list ::= tuple-pattern-element (COMMA tuple-pattern-element)*
  tuple-pattern-element ::= pattern | IDENTIFIER COLON pattern
  enum-case-pattern ::= type-identifier? DOT enum-case-name tuple-pattern?
  optional-pattern ::= identifier-pattern OP_QUESTION
  expression-pattern ::= expression

  // RULES: GENERIC PARAMETERS and ARGUMENTS
  generic-parameter-clause ::= (OP_LANGLE generic-parameter-list OP_RANGLE)
  generic-parameter-list ::= generic-parameter (COMMA generic-parameter)*
  generic-parameter ::= type-name (COLON type-identifier | COLON protocol-composition-type)?
  generic-where-clause ::= (KW_WHERE requirement-list)
  requirement-list ::= requirement (COMMA requirement)*
  requirement ::= conformance-requirement | same-type-requirement
  conformance-requirement ::= (type-identifier COLON (type-identifier | protocol-composition-type))
  same-type-requirement ::= (type-identifier OP_EQ type)
  generic-argument-clause ::= (OP_LANGLE generic-argument-list OP_RANGLE)
  generic-argument-list ::= generic-argument (COMMA generic-argument)*
  generic-argument ::= type

  // RULES:
any-keyword ::=
  KW_PND_AVAILABLE
  | KW_PND_COLORLITERAL
  | KW_PND_ELSE
  | KW_PND_ELSEIF
  | KW_PND_ENDIF
  | KW_PND_FILELITERAL
  | KW_PND_IF
  | KW_PND_IMAGELITERAL
  | KW_PND_KEYPATH
  | KW_PND_SELECTOR
  | KW_PND_SOURCELOCATION
  | KW_PND_UNAVAILABLE
  | KW_UPPER_ANY
  | KW_LOWER_ANY
  | KW_ASSOCIATEDTYPE
  | KW_AWAIT
  | KW_BORROWING
  | KW_BREAK
  | KW_CASE
  | KW_CLASS
  | KW_CONSUMING
  | KW_CONTINUE
  | KW_DEFAULT
  | KW_DEFER
  | KW_DEINIT
  | KW_DO
  | KW_ELSE
  | KW_ENUM
  | KW_EXTENSION
  | KW_FALLTHROUGH
  | KW_FALSE
  | KW_FILEPRIVATE
  | KW_FOR
  | KW_FUNC
  | KW_GUARD
  | KW_IF
  | KW_IMPORT
  | KW_IN
  | KW_INIT
  | KW_INOUT
  | KW_INTERNAL
  | KW_LET
  | KW_NIL
  | KW_NONISOLATED
  | KW_OPEN
  | KW_OPERATOR
  | KW_PRECEDENCEGROUP
  | KW_PRIVATE
  | KW_LOWER_PROTOCOL_DECL
  | KW_PUBLIC
  | KW_REPEAT
  | KW_RETURN
  | KW_LOWER_SELF
  | KW_UPPER_SELF
  | KW_STATIC
  | KW_STRUCT
  | KW_SUPER
  | KW_SWITCH
  | KW_SUBSCRIPT
  | KW_THROWS
  | KW_TRUE
  | KW_TRY
  | KW_TYPEALIAS
  | KW_VAR
  | KW_WHERE
  | KW_WHILE
  | KW_CATCH
  | KW_THROW
  | KW_RETHROWS
  | KW_ASSOCIATIVITY
  | KW_ASYNC
  | KW_CONVENIENCE
  | KW_DIDSET
  | KW_DYNAMIC
  | KW_FINAL
  | KW_GET
  | KW_INDIRECT
  | KW_INFIX
  | KW_LAZY
  | KW_LEFT
  | KW_MUTATING
  | KW_NONE
  | KW_NONMUTATING
  | KW_OPTIONAL
  | KW_OVERRIDE
  | KW_PACKAGE
  | KW_POSTFIX
  | KW_PRECEDENCE
  | KW_PREFIX
  | KW_UPPER_PROTOCOL
  | KW_REQUIRED
  | KW_RIGHT
  | KW_SET
  | KW_SOME
  | KW_UPPER_TYPE
  | KW_UNOWNED
  | KW_WEAK
  | KW_WILLSET

// balanced-token-punctuation can be any punctuation except (, ), [, ], {, or }
  balanced-token-punctuation ::=
  KW_UNDERSCORE
  | OP_TYPE_CAST_BANG
  | OP_TYPE_CAST_OPT
  | OP_TYPE_CAST
  | OP_TYPE_CHECK
  | OP_OVERFLOW_BITSHIFT_LEFT_AND_ASSIGNMENT
  | OP_OVERFLOW_BITSHIFT_RIGHT_AND_ASSIGNMENT
  | OP_TRIPLE_LANGLE
  | OP_TRIPLE_RANGLE
  | OP_IDENTICAL
  | OP_NOT_IDENTICAL
  | OP_BITSHIFT_LEFT_AND_ASSIGNMENT
  | OP_BITSHIFT_RIGHT_AND_ASSIGNMENT
  | OP_OVERFLOW_BITSHIFT_LEFT
  | OP_OVERFLOW_BITSHIFT_RIGHT
  | OP_HALFOPEN_RANGE
  | OP_CLOSED_RANGE
  | OP_POINTWISE_EQ
  | OP_POINTWISE_NOT_EQ
  | OP_OVERFLOW_ADD_AND_ASSIGNMENT
  | OP_OVERFLOW_SUB_AND_ASSIGNMENT
  | OP_OVERFLOW_MULT_AND_ASSIGNMENT
  | OP_POINTWISE_BITWISE_AND_AND_ASSIGNMENT
  | OP_POINTWISE_BITWISE_OR_AND_ASSIGNMENT
  | OP_POINTWISE_BITWISE_XOR_AND_ASSIGNMENT
  | OP_POINTWISE_LESS_THAN_OR_EQ
  | OP_POINTWISE_GREATER_THAN_OR_EQ
  | OP_EQ
  | OP_LOGICAL_AND
  | OP_OVERFLOW_ADD
  | OP_OVERFLOW_SUB
  | OP_OVERFLOW_MULT
  | OP_BITWISE_AND_ASSIGNMENT
  | OP_BITWISE_OR_ASSIGNMENT
  | OP_BITWISE_XOR_ASSIGNMENT
  | OP_PATTERN_MATCH
  | OP_NOT_EQ
  | OP_BITSHIFT_LEFT
  | OP_BITSHIFT_RIGHT
  | OP_LESS_THAN_OR_EQ
  | OP_GREATER_THAN_OR_EQ
  | OP_POINTWISE_LESS_THAN
  | OP_POINTWISE_GREATER_THAN
  | OP_ADD_ASSIGNMENT
  | OP_SUB_ASSIGNMENT
  | OP_MULT_ASSIGNMENT
  | OP_DIV_ASSIGNMENT
  | OP_MODULO_ASSIGNMENT
  | OP_LOGICAL_OR
  | OP_POINTWISE_BITWISE_OR
  | OP_POINTWISE_BITWISE_XOR
  | OP_POINTWISE_NOT
  | OP_NIL_COALESCING
  | OP_TERNARY_CONDITIONAL
  | FWD_ARROW
  | AT_SYMBOL
  | POUND
  | COMMA
  | COLON
  | SEMICOLON
  | DOT
  | BACKSLASH
  | FWDSLASH
  | OP_ASSIGNMENT
  | OP_ADD
  | OP_SUB
  | OP_MULT
  | OP_MODULO
  | OP_NOT
  | OP_LANGLE
  | OP_RANGLE
  | OP_BITWISE_AND
  | OP_BITWISE_OR
  | OP_BITWISE_XOR
  | OP_BITWISE_NOT
  | OP_QUESTION

  // LEXICAL TOKEN DEFINITIONS:

  // GENERAL/SHARED ACROSS STATES
  token COMMENT_TEXT
  token SINGLELINE_COMMENT
  token QUOTED_IDENTIFIER

  token STRING_INTERPOLATION_START
  token STRING_TEXT
  token STRING_START
  token STRING_END
  token STRING_ESCAPED_SEQUENCE
  token MULTILINE_STRING_START
  token MULTILINE_STRING_END
  token MULTILINE_STRING_ESCAPED_NEWLINE
  token MULTILINE_STRING_ESCAPED_SEQUENCE
  token EXTENDED_STRING_START
  token EXTENDED_STRING_END
  token EXTENDED_MULTILINE_STRING_START
  token EXTENDED_MULTILINE_STRING_END
  token MULTILINE_COMMENT_START
  token MULTILINE_COMMENT_END
  token REGEXP_LITERAL_START
  token REGEXP_LITERAL_END
  token REGEXP_LITERAL
  token REGEXP

  // KEYWORDS (Pound Sign #)
  token KW_PND_AVAILABLE
  token KW_PND_COLORLITERAL
  token KW_PND_ELSE
  token KW_PND_ELSEIF
  token KW_PND_ENDIF
  token KW_PND_FILELITERAL
  token KW_PND_IF
  token KW_PND_IMAGELITERAL
  token KW_PND_KEYPATH
  token KW_PND_SELECTOR
  token KW_PND_SOURCELOCATION
  token KW_PND_UNAVAILABLE

  // KEYWORDS reserved for DISTINCT USE
  token KW_UPPER_ANY
  token KW_LOWER_ANY
  token KW_ASSOCIATEDTYPE
  token KW_AWAIT
  token KW_BORROWING
  token KW_BREAK
  token KW_CASE
  token KW_CLASS
  token KW_CONSUMING
  token KW_CONTINUE
  token KW_DEFAULT
  token KW_DEFER
  token KW_DEINIT
  token KW_DO
  token KW_ELSE
  token KW_ENUM
  token KW_EXTENSION
  token KW_FALLTHROUGH
  token KW_FALSE
  token KW_FILEPRIVATE
  token KW_FOR
  token KW_FUNC
  token KW_GUARD
  token KW_IF
  token KW_IMPORT
  token KW_IN
  token KW_INIT
  token KW_INOUT
  token KW_INTERNAL
  token KW_LET
  token KW_NIL
  token KW_NONISOLATED
  token KW_OPEN
  token KW_OPERATOR
  token KW_PRECEDENCEGROUP
  token KW_PRIVATE
  token KW_LOWER_PROTOCOL_DECL
  token KW_PUBLIC
  token KW_REPEAT
  token KW_RETURN
  token KW_LOWER_SELF
  token KW_UPPER_SELF
  token KW_STATIC
  token KW_STRUCT
  token KW_SUPER
  token KW_SWITCH
  token KW_SUBSCRIPT
  token KW_THROWS
  token KW_TRUE
  token KW_TRY
  token KW_TYPEALIAS
  token KW_VAR
  token KW_WHERE
  token KW_WHILE

  // KEYWORDS reserved for DIFFERING USES depending on the context.
  token KW_CATCH
  token KW_THROW
  token KW_RETHROWS

  // KEYWORDS reserved ONLY IN PARTICULAR CONTEXTS. Outside the context in which they appear in the grammar, they can be used as identifiers.
token KW_ASSOCIATIVITY
token KW_ASYNC
token KW_CONVENIENCE
token KW_DIDSET
token KW_DYNAMIC
token KW_FINAL
token KW_GET
token KW_INDIRECT
token KW_INFIX
token KW_LAZY
token KW_LEFT
token KW_MUTATING
token KW_NONE
token KW_NONMUTATING
token KW_OPTIONAL
token KW_OVERRIDE
token KW_PACKAGE
token KW_POSTFIX
token KW_PRECEDENCE
token KW_PREFIX
token KW_UPPER_PROTOCOL
token KW_REQUIRED
token KW_RIGHT
token KW_SET
token KW_SOME
token KW_UPPER_TYPE
token KW_UNOWNED
token KW_WEAK
token KW_WILLSET

  // KEYWORDS reserved for PATTERNS
  token KW_UNDERSCORE

  // FLOATING POINT LITERALS
  token FLOATING_POINT_LITERAL
  token HEX_FLOATING_POINT_LITERAL
  token DECIMAL_FLOATING_POINT_LITERAL

  // INTEGER LITERALS
  token BINARY_LITERAL
  token OCTAL_LITERAL
  token HEX_LITERAL
  token DECIMAL_LITERAL

  // OPERATORS AND PUNCTUATION (Fixed String Literals)
  token OP_TYPE_CAST_BANG
  token OP_TYPE_CAST_OPT
  token OP_TYPE_CAST
  token OP_TYPE_CHECK
  token OP_OVERFLOW_BITSHIFT_LEFT_AND_ASSIGNMENT
  token OP_OVERFLOW_BITSHIFT_RIGHT_AND_ASSIGNMENT
  token OP_TRIPLE_LANGLE
  token OP_TRIPLE_RANGLE
  token OP_IDENTICAL
  token OP_NOT_IDENTICAL
  token OP_BITSHIFT_LEFT_AND_ASSIGNMENT
  token OP_BITSHIFT_RIGHT_AND_ASSIGNMENT
  token OP_OVERFLOW_BITSHIFT_LEFT
  token OP_OVERFLOW_BITSHIFT_RIGHT
  token OP_HALFOPEN_RANGE
  token OP_CLOSED_RANGE
  token OP_POINTWISE_EQ
  token OP_POINTWISE_NOT_EQ
  token OP_OVERFLOW_ADD_AND_ASSIGNMENT
  token OP_OVERFLOW_SUB_AND_ASSIGNMENT
  token OP_OVERFLOW_MULT_AND_ASSIGNMENT
  token OP_POINTWISE_BITWISE_AND_AND_ASSIGNMENT
  token OP_POINTWISE_BITWISE_OR_AND_ASSIGNMENT
  token OP_POINTWISE_BITWISE_XOR_AND_ASSIGNMENT
  token OP_POINTWISE_LESS_THAN_OR_EQ
  token OP_POINTWISE_GREATER_THAN_OR_EQ
  token OP_EQ
  token OP_LOGICAL_AND
  token OP_OVERFLOW_ADD
  token OP_OVERFLOW_SUB
  token OP_OVERFLOW_MULT
  token OP_BITWISE_AND_ASSIGNMENT
  token OP_BITWISE_OR_ASSIGNMENT
  token OP_BITWISE_XOR_ASSIGNMENT
  token OP_PATTERN_MATCH
  token OP_NOT_EQ
  token OP_BITSHIFT_LEFT
  token OP_BITSHIFT_RIGHT
  token OP_LESS_THAN_OR_EQ
  token OP_GREATER_THAN_OR_EQ
  token OP_POINTWISE_LESS_THAN
  token OP_POINTWISE_GREATER_THAN
  token OP_ADD_ASSIGNMENT
  token OP_SUB_ASSIGNMENT
  token OP_MULT_ASSIGNMENT
  token OP_DIV_ASSIGNMENT
  token OP_MODULO_ASSIGNMENT
  token OP_LOGICAL_OR
  token OP_POINTWISE_BITWISE_OR
  token OP_POINTWISE_BITWISE_XOR
  token OP_POINTWISE_NOT
  token OP_NIL_COALESCING
  token OP_TERNARY_CONDITIONAL
  token FWD_ARROW

  // SPECIAL: RPAREN
  token STRING_INTERPOLATION_END
  token RPAREN

  // FIXIE SINGLE-CHAR PUNCTUATION:
  token LPAREN
  token AT_SYMBOL
  token POUND
  token LBRACE
  token RBRACE
  token LBRACKET
  token RBRACKET
  token COMMA
  token COLON
  token SEMICOLON
  token DOT
  token BACKSLASH

  // FIXIE SINGLE-CHARs that CAN ALSO START CUSTOM OPERATORS
  token FWDSLASH
  token OP_ASSIGNMENT
  token OP_ADD
  token OP_SUB
  token OP_MULT
  token OP_MODULO
  token OP_NOT
  token OP_LANGLE
  token OP_RANGLE
  token OP_BITWISE_AND
  token OP_BITWISE_OR
  token OP_BITWISE_XOR
  token OP_BITWISE_NOT
  token OP_QUESTION

  // IMPLICIT PARAMETER NAMES, PROPERTY WRAPPER PROJECTIONS
  token IMPLICIT_PARAMETER_NAME
  token PROPERTY_WRAPPER_PROJECTION

  // CUSTOM OPERATORS
  token DOT_OPERATOR
  token OPERATOR
  token IDENTIFIER

  // TOKENS: REGEX LITERALS (FUTURE)

  // END FILE Swift.bnf
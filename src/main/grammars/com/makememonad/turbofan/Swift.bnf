  /*
  // Swift Language Grammar for CLion Plugin
  // BEGIN FILE Swift.bnf
  // Reference Links:
  // https://docs.swift.org/swift-book/documentation/the-swift-programming-language/aboutthelanguagereference/
  // https://docs.swift.org/swift-book/documentation/the-swift-programming-language/lexicalstructure/
  // https://docs.swift.org/swift-book/documentation/the-swift-programming-language/summaryofthegrammar/
  // Above references are:
  // Copyright © 2014–2023 Apple Inc. and the Swift project authors. All rights reserved.
  // This document is made available under a Creative Commons Attribution 4.0 International (CC BY 4.0) License.
  // Swift and the Swift logo are trademarks of Apple Inc.
  //
  // https://github.com/JetBrains/Grammar-Kit
  // Above reference is:
  // Pertinent License Info goes here...
  //
  */

  {
  // Generates methods like `getKwIf()` etc. on composite elements
  generatePsi=true
  generateTokens=true
  generateTokenAccessors=true
  parserClass="com.makememonad.turbofan.language.swift.parser.SwiftParser"
  parserUtilClass="com.makememonad.turbofan.language.swift.parser.SwiftParserUtil"
  // implements="com.intellij.psi.tree.IElementType"
  // Common base for PSI elements
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  // Where IElementType constants go
  elementTypeHolderClass="com.makememonad.turbofan.language.swift.psi.SwiftTypes"
  // Base for element types
  elementTypeClass="com.intellij.psi.tree.IElementType"
  // Base for token types (often same as elementTypeClass)
  tokenTypeClass="com.intellij.psi.tree.IElementType"
  // e.g., Swift<RuleName> for interfaces
  psiClassPrefix="Swift"
  // e.g., SwiftImpl<RuleName> for implementations
  psiImplClassSuffix="SwiftImpl"
  // Where PSI interfaces go
  psiPackage="com.makememonad.turbofan.language.swift.psi"
  // Where PSI impls go
  psiImplPackage="com.makememonad.turbofan.language.swift.psi.impl"
  // For custom methods on PSI nodes
  psiImplUtilClass="com.makememonad.turbofan.language.swift.psi.impl.SwiftPsiImplUtil"
  // elementTypeFactory()= com.makememonad.turbofan.language.swift.psi.stubs.SwiftStubElementTypeFactory.create
  }
  // GRAMMAR RULE DEFINITIONS:

  // RULES: LEXICAL STRUCTURE (Mainly handled in the JFlex with tokens redefined below...
  // TODO: Check all of this against the existing JFlex setup and also the Swift 6.1 Spec and Grammar Summary...

  swiftFile ::= declaration*

  literal ::= numeric-literal | string-literal | regular-expression-literal | boolean-literal | nil-literal
  numeric-literal ::= OP_SUB? integer-literal | OP_SUB? floating-point-literal
  integer-literal ::= BINARY_LITERAL | OCTAL_LITERAL | DECIMAL_LITERAL | HEXADECIMAL_LITERAL
  floating-point-literal ::= DECIMAL_FLOATING_POINT_LITERAL | HEX_FLOATING_POINT_LITERAL
  string-literal ::= static-string-literal // | interpolated-string-literal
  static-string-literal ::= STRING_START STRING_TEXT* STRING_END | MULTILINE_STRING_START MULTILINE_STRING_TEXT* MULTILINE_STRING_END
  // regular-expression-literal ::= REGEX_LITERAL
  boolean-literal ::= KW_TRUE | KW_FALSE
  nil-literal ::= KW_NIL
  sign ::= OP_ADD | OP_SUB
  infix-operator ::= OPERATOR
  prefix-operator ::= OPERATOR
  postfix-operator ::= OPERATOR

  // RULES: TYPES

  // Type Intermediate
  type ::= function-type | array-type | dictionary-type | type-identifier | tuple-type | optional-type | implicitly-unwrapped-optional-type | protocol-composition-type | opaque-type | metatype-type | any-type | self-type | LPAREN type RPAREN
  type-annotation ::= COLON attributes? KW_INOUT? type
  type-identifier ::= type-name generic-argument-clause? | type-name generic-argument-clause? DOT type-identifier
  type-name ::= IDENTIFIER
  // Tuple Types
  tuple-type ::= LPAREN RPAREN | LPAREN tuple-type-element COMMA tuple-type-element-list RPAREN
  tuple-type-element-list ::= tuple-type-element | tuple-type-element COMMA tuple-type-element-list
  tuple-type-element ::= element-name type-annotation | type
  element-name ::= IDENTIFIER
  // Function Types
  function-type ::= attributes? function-type-argument-clause KW_ASYNC? throws-clause? KW_FWD_ARROW type
  function-type-argument-clause ::= LPAREN RPAREN | LPAREN function-type-argument-list KW_ELLIPSIS? RPAREN
  function-type-argument-list ::= function-type-argument | function-type-argument COMMA function-type-argument-list
  function-type-argument ::= attributes? KW_INOUT? type | argument-label type-annotation
  argument-label ::= IDENTIFIER
  throws-clause ::= KW_THROWS | KW_THROWS LPAREN type RPAREN
  // Array Types
  array-type ::= LBRACKET type RBRACKET
  // Dict Types
  dictionary-type ::= LBRACKET type COLON type RBRACKET
  // Opt Types
  optional-type ::= type OP_QUESTION
  implicitly-unwrapped-optional-type ::= type OP_NOT
  protocol-composition-type ::= type-identifier OP_BITWISE_AND protocol-composition-continuation
  protocol-composition-continuation ::= type-identifier | protocol-composition-type
  opaque-type ::= KW_SOME type
  boxed-protocol-type ::= KW_LOWER_ANY type
  metatype-type ::= type DOT KW_UPPER_TYPE | type DOT KW_UPPER_PROTOCOL
  any-type ::= KW_UPPER_ANY
  self-type ::= KW_UPPER_SELF
  type-inheritance-clause ::= COLON type-inheritance-list
  type-inheritance-list ::= attributes? type-identifier | attributes? type-identifier COMMA type-inheritance-list
  // RULES: EXPRESSIONS
  expression ::= try-operator? await-operator? prefix-expression infix-expressions?
  prefix-expression ::= prefix-operator? postfix-expression | in-out-expression
  in-out-expression ::= OP_BITWISE_AND primary-expression
  try-operator ::= KW_TRY | KW_TRY OP_QUESTION | KW_TRY OP_NOT
  await-operator ::= KW_AWAIT
  infix-expression ::= infix-operator prefix-expression | assignment-operator try-operator? await-operator? prefix-expression | conditional-operator try-operator? await-operator? prefix-expression | type-casting-operator
  infix-expressions ::= infix-expression infix-expressions?
  assignment-operator ::= OP_ASSIGNMENT
  conditional-operator ::= OP_QUESTION expression COLON
  type-casting-operator ::= OP_TYPE_CHECK type | OP_TYPE_CAST type | OP_TYPE_CAST OP_QUESTION type | OP_TYPE_CAST OP_NOT type
  primary-expression ::= IDENTIFIER generic-argument-clause? | literal-expression | self-expression | superclass-expression | conditional-expression | closure-expression | parenthesized-expression | tuple-expression | implicit-member-expression | wildcard-expression | macro-expansion-expression | key-path-expression | selector-expression | key-path-string-expression
  literal-expression ::= literal | array-literal | dictionary-literal | playground-literal
  array-literal ::= LBRACKET array-literal-items? RBRACKET
  array-literal-items ::= array-literal-item COMMA? | array-literal-item COMMA array-literal-items
  array-literal-item ::= expression
  dictionary-literal ::= LBRACKET dictionary-literal-items RBRACKET | LBRACKET COLON RBRACKET
  dictionary-literal-items ::= dictionary-literal-item COMMA? | dictionary-literal-item COMMA dictionary-literal-items
  dictionary-literal-item ::= expression COLON expression
  playground-literal ::= KW_PND_COLORLITERAL LPAREN red COLON expression COMMA green COLON expression COMMA blue COLON expression COMMA alpha COLON expression RPAREN | KW_PND_FILELITERAL LPAREN KW_RESOURCENAME COLON expression RPAREN | KW_PND_IMAGELITERAL LPAREN resourceName COLON expression RPAREN
  self-expression ::= KW_LOWER_SELF | self-method-expression | self-subscript-expression | self-initializer-expression
  self-method-expression ::= KW_LOWER_SELF DOT IDENTIFIER
  self-subscript-expression ::= KW_LOWER_SELF LBRACKET function-call-argument-list RBRACKET
  self-initializer-expression ::= KW_LOWER_SELF DOT KW_INIT
  superclass-expression ::= superclass-method-expression | superclass-subscript-expression | superclass-initializer-expression
  superclass-method-expression ::= KW_SUPER DOT IDENTIFIER
  superclass-subscript-expression ::= KW_SUPER LBRACKET function-call-argument-list RBRACKET
  superclass-initializer-expression ::= KW_SUPER DOT KW_INIT
  conditional-expression ::= if-expression | switch-expression
  if-expression ::= KW_IF condition-list LBRACE statement RBRACE if-expression-tail
  if-expression-tail ::= KW_ELSE if-expression | KW_ELSE LBRACE statement RBRACE
  switch-expression ::= KW_SWITCH expression LBRACE switch-expression-cases RBRACE
  switch-expression-cases ::= switch-expression-case switch-expression-cases?
  switch-expression-case ::= case-label statement | default-label statement
  closure-expression ::= LBRACE attributes? closure-signature? statements? RBRACE
  closure-signature ::= capture-list? closure-parameter-clause async? throws-clause? function-result? KW_IN | capture-list KW_IN
  closure-parameter-clause ::= LPAREN RPAREN | LPAREN closure-parameter-list RPAREN | identifier-list
  closure-parameter-list ::= closure-parameter | closure-parameter COMMA closure-parameter-list
  closure-parameter ::= closure-parameter-name type-annotation? | closure-parameter-name type-annotation ELLIPSIS
  closure-parameter-name ::= IDENTIFIER
  capture-list ::= LBRACKET capture-list-items RBRACKET
  capture-list-items ::= capture-list-item | capture-list-item COMMA capture-list-items
  capture-list-item ::= capture-specifier? IDENTIFIER | capture-specifier? IDENTIFIER OP_ASSIGNMENT expression | capture-specifier? self-expression

  capture-specifier ::= KW_WEAK | KW_UNOWNED | KW_UNOWNED LPAREN KW_SAFE RPAREN | KW_UNOWNED LPAREN KW_UNSAFE RPAREN
  implicit-member-expression ::= DOT IDENTIFIER | DOT IDENTIFIER DOT postfix-expression
  parenthesized-expression ::= LPAREN expression RPAREN
  tuple-expression ::= LPAREN RPAREN | LPAREN tuple-element COMMA tuple-element-list RPAREN
  tuple-element-list ::= tuple-element | tuple-element COMMA tuple-element-list
  tuple-element ::= expression | IDENTIFIER COLON expression
  wildcard-expression ::= OP_UNDERSCORE

  macro-expansion-expression ::= POUND IDENTIFIER generic-argument-clause? function-call-argument-clause? trailing-closures?

  key-path-expression ::= BACKSLASH type? DOT key-path-components
  key-path-components ::= key-path-component | key-path-component DOT key-path-components
  key-path-component ::= IDENTIFIER key-path-postfixes? | key-path-postfixes
  key-path-postfixes ::= key-path-postfix key-path-postfixes?
  key-path-postfix ::= OP_QUESTION | OP_NOT | KW_LOWER_SELF | LBRACKET function-call-argument-list RBRACKET

  selector-expression ::= KW_PND_SELECTOR LPAREN expression RPAREN | KW_PND_SELECTOR LPAREN getter COLON expression RPAREN | KW_PND_SELECTOR LPAREN setter COLON expression RPAREN
  key-path-string-expression ::= KW_PND_KEYPATH LPAREN expression RPAREN

  postfix-expression ::= primary-expression | postfix-expression postfix-operator | function-call-expression | initializer-expression | explicit-member-expression | postfix-self-expression | subscript-expression | forced-value-expression | optional-chaining-expression

  function-call-expression ::= postfix-expression function-call-argument-clause | postfix-expression function-call-argument-clause? trailing-closures
  function-call-argument-clause ::= LPAREN RPAREN | LPAREN function-call-argument-list RPAREN
  function-call-argument-list ::= function-call-argument | function-call-argument COMMA function-call-argument-list
  function-call-argument ::= expression | IDENTIFIER COLON expression | operator | IDENTIFIER COLON operator
  trailing-closures ::= closure-expression labeled-trailing-closures?
  labeled-trailing-closures ::= labeled-trailing-closure labeled-trailing-closures?
  labeled-trailing-closure ::= IDENTIFIER COLON closure-expression
  initializer-expression ::= postfix-expression DOT KW_INIT | postfix-expression DOT KW_INIT LPAREN argument-names RPAREN
  explicit-member-expression ::= postfix-expression DOT decimal-digits | postfix-expression DOT IDENTIFIER generic-argument-clause? | postfix-expression DOT IDENTIFIER LPAREN argument-names RPAREN | postfix-expression conditional-compilation-block
  argument-names ::= argument-name argument-names?
  argument-name ::= IDENTIFIER COLON
  postfix-self-expression ::= postfix-expression DOT KW_LOWER_SELF
  subscript-expression ::= postfix-expression LBRACKET function-call-argument-list RBRACKET
  forced-value-expression ::= postfix-expression OP_NOT
  optional-chaining-expression ::= postfix-expression OP_QUESTION
  // RULES: STATEMENTS
  statement ::= (expression | declaration | loop-statement | branch-statement | labeled-statement | control-transfer-statement | defer-statement | do-statement) SEMICOLON? | compiler-control-statement | statement statements?
  loop-statement ::= for-in-statement | while-statement | repeat-while-statement
  for-in-statement ::= for case? pattern in expression where-clause? code-block
  while-statement ::= KW_WHILE condition-list code-block
  condition-list ::= condition | condition COMMA condition-list
  condition ::= expression | availability-condition | case-condition | optional-binding-condition
  case-condition ::= KW_CASE pattern initializer
  optional-binding-condition ::= KW_LET pattern initializer? | var pattern initializer?
  repeat-while-statement ::= KW_REPEAT code-block KW_WHILE expression
  branch-statement ::= if-statement | guard-statement | switch-statement
  if-statement ::= KW_IF condition-list code-block else-clause?
  else-clause ::= KW_ELSE code-block | KW_ELSE if-statement
  guard-statement ::= KW_GUARD condition-list KW_ELSE code-block
  switch-statement ::= switch expression LBRACE switch-cases? RBRACE
  switch-cases ::= switch-case switch-cases?
  switch-case ::= case-label statements | default-label statements | conditional-switch-case
  case-label ::= attributes? KW_CASE case-item-list COLON
  case-item-list ::= pattern where-clause? | pattern where-clause? COMMA case-item-list
  default-label ::= attributes? KW_DEFAULT COLON
  where-clause ::= KW_WHERE where-expression
  where-expression ::= expression
  conditional-switch-case ::= switch-if-directive-clause switch-elseif-directive-clauses? switch-else-directive-clause? endif-directive
  switch-if-directive-clause ::= if-directive compilation-condition switch-cases?
  switch-elseif-directive-clauses ::= elseif-directive-clause switch-elseif-directive-clauses?
  switch-elseif-directive-clause ::= elseif-directive compilation-condition switch-cases?
  switch-else-directive-clause ::= else-directive switch-cases?
  labeled-statement ::= statement-label loop-statement | statement-label if-statement | statement-label switch-statement | statement-label do-statement
  statement-label ::= label-name COLON
  label-name ::= IDENTIFIER
  control-transfer-statement ::= break-statement | continue-statement | fallthrough-statement | return-statement | throw-statement
  break-statement ::= KW_BREAK label-name?
  continue-statement ::= KW_CONTINUE label-name?
  fallthrough-statement ::= KW_FALLTHROUGH
  return-statement ::= return expression?
  throw-statement ::= throw expression
  defer-statement ::= KW_DEFER code-block
  do-statement ::= KW_DO throws-clause? code-block catch-clauses?
  catch-clauses ::= catch-clause catch-clauses?
  catch-clause ::= KW_CATCH catch-pattern-list? code-block
  catch-pattern-list ::= catch-pattern | catch-pattern COMMA catch-pattern-list
  catch-pattern ::= pattern where-clause?
  compiler-control-statement ::= conditional-compilation-block | line-control-statement | diagnostic-statement
  conditional-compilation-block ::= if-directive-clause elseif-directive-clauses? else-directive-clause? endif-directive
  if-directive-clause ::= if-directive compilation-condition statements?
  elseif-directive-clauses ::= elseif-directive-clause elseif-directive-clauses?
  elseif-directive-clause ::= elseif-directive compilation-condition statements?
  else-directive-clause ::= else-directive statements?
  if-directive ::= KW_PND_IF
  elseif-directive ::= KW_PND_ELSEIF
  else-directive ::= KW_PND_ELSE
  endif-directive ::= KW_PND_ENDIF
  compilation-condition ::= platform-condition
  compilation-condition ::= IDENTIFIER | boolean-literal | LPAREN compilation-condition RPAREN | OP_NOT compilation-condition | compilation-condition OP_LOGICAL_AND compilation-condition | compilation-condition OP_LOGICAL_OR compilation-condition
  platform-condition ::= os LPAREN operating-system RPAREN | arch LPAREN architecture RPAREN | swift LPAREN OP_GREATER_THAN_OR_EQ swift-version RPAREN | swift LPAREN OP_LANGLE swift-version RPAREN | compiler LPAREN OP_LESS_THAN_OR_EQ swift-version RPAREN | compiler LPAREN OP_LANGLE swift-version RPAREN | canImport LPAREN import-path RPAREN | targetEnvironment LPAREN environment RPAREN
  operating-system ::= macOS | iOS | watchOS | tvOS | visionOS | Linux | Windows
  architecture ::= i386 | x86_64 | arm | arm64
  swift-version ::= decimal-digits swift-version-continuation?
  swift-version-continuation ::= DOT decimal-digits swift-version-continuation?
  environment ::= simulator | macCatalyst
  line-control-statement ::= KW_PND_SOURCELOCATION LPAREN file COLON file-path COMMA line COLON line-number RPAREN | KW_PND_SOURCELOCATION LPAREN RPAREN
  line-number ::= DECIMAL_LITERAL
  file-path ::= static-string-literal
  availability-condition ::= KW_PND_AVAILABLE LPAREN availability-arguments RPAREN | KW_PND_UNAVAILABLE LPAREN availability-arguments RPAREN
  availability-arguments ::= availability-argument | availability-argument COMMA availability-arguments
  availability-argument ::= platform-name platform-version | OP_MULT
  platform-name ::= iOS | iOSApplicationExtension | macOS | macOSApplicationExtension | macCatalyst | macCatalystApplicationExtension | watchOS | watchOSApplicationExtension | tvOS | tvOSApplicationExtension | visionOS | visionOSApplicationExtension
  platform-version ::= decimal-digits | decimal-digits DOT decimal-digits | decimal-digits DOT decimal-digits DOT decimal-digits
  // RULES: DECLARATIONS
  declaration ::= import-declaration | constant-declaration | variable-declaration | typealias-declaration | function-declaration | enum-declaration | struct-declaration | class-declaration | actor-declaration | protocol-declaration | initializer-declaration | deinitializer-declaration | extension-declaration | subscript-declaration | operator-declaration | precedence-group-declaration
  top-level-declaration ::= statements?
  code-block ::= LBRACE statements? RBRACE
  import-declaration ::= attributes? KW_IMPORT import-kind? import-path
  import-kind ::= KW_TYPEALIAS | KW_STRUCT | KW_CLASS | KW_ENUM | KW_LOWER_PROTOCOL_DECL | KW_LET | KW_VAR | KW_FUNC
  import-path ::= IDENTIFIER | IDENTIFIER DOT import-path
  constant-declaration ::= attributes? declaration-modifiers? let pattern-initializer-list
  pattern-initializer-list ::= pattern-initializer | pattern-initializer COMMA pattern-initializer-list
  pattern-initializer ::= pattern initializer?
  initializer ::= OP_ASSIGNMENT expression
  variable-declaration ::= variable-declaration-head pattern-initializer-list | variable-declaration-head variable-name type-annotation code-block | variable-declaration-head variable-name type-annotation getter-setter-block | variable-declaration-head variable-name type-annotation getter-setter-keyword-block | variable-declaration-head variable-name initializer willSet-didSet-block | variable-declaration-head variable-name type-annotation initializer? willSet-didSet-block
  variable-declaration-head ::= attributes? declaration-modifiers? KW_VAR
  variable-name ::= IDENTIFIER
  getter-setter-block ::= code-block | LBRACE getter-clause setter-clause? RBRACE | LBRACE setter-clause getter-clause RBRACE
  getter-clause ::= attributes? mutation-modifier? KW_GET code-block
  setter-clause ::= attributes? mutation-modifier? KW_SET setter-name? code-block
  setter-name ::= LPAREN IDENTIFIER RPAREN
  getter-setter-keyword-block ::= LBRACE getter-keyword-clause setter-keyword-clause? RBRACE | LBRACE setter-keyword-clause getter-keyword-clause RBRACE
  getter-keyword-clause ::= attributes? mutation-modifier? KW_GET
  setter-keyword-clause ::= attributes? mutation-modifier? KW_SET
  willSet-didSet-block ::= LBRACE willSet-clause didSet-clause? RBRACE | LBRACE didSet-clause willSet-clause? RBRACE
  willSet-clause ::= attributes? KW_WILLSET setter-name? code-block
  didSet-clause ::= attributes? KW_DIDSET setter-name? code-block
  typealias-declaration ::= attributes? access-level-modifier? KW_TYPEALIAS typealias-name generic-parameter-clause? typealias-assignment
  typealias-name ::= IDENTIFIER
  typealias-assignment ::= OP_ASSIGNMENT type

  function-declaration ::= function-head function-name generic-parameter-clause? function-signature generic-where-clause? function-body?
  function-head ::= attributes? declaration-modifiers? KW_FUNC
  function-name ::= IDENTIFIER | operator
  function-signature ::= parameter-clause KW_ASYNC? throws-clause? function-result? | parameter-clause KW_ASYNC? KW_RETHROWS function-result?
  function-result ::= KW_FWD_ARROW attributes? type
  function-body ::= code-block
  parameter-clause ::= LPAREN RPAREN | LPAREN parameter-list RPAREN
  parameter-list ::= parameter | parameter COMMA parameter-list
  parameter ::= external-parameter-name? local-parameter-name parameter-type-annotation default-argument-clause? | external-parameter-name? local-parameter-name parameter-type-annotation | external-parameter-name? local-parameter-name parameter-type-annotation KW_ELLIPSIS
  external-parameter-name ::= IDENTIFIER
  local-parameter-name ::= IDENTIFIER
  parameter-type-annotation ::= COLON attributes? parameter-modifier? type
  parameter-modifier ::= KW_INOUT | KW_BORROWING | KW_CONSUMING default-argument-clause ::= OP_ASSIGNMENT expression

  enum-declaration ::= attributes? access-level-modifier? union-style-enum | attributes? access-level-modifier? raw-value-style-enum
  union-style-enum ::= KW_INDIRECT? KW_ENUM enum-name generic-parameter-clause? type-inheritance-clause? generic-where-clause? LBRACE union-style-enum-members? RBRACE
  union-style-enum-members ::= union-style-enum-member union-style-enum-members?
  union-style-enum-member ::= declaration | union-style-enum-case-clause | compiler-control-statement
  union-style-enum-case-clause ::= attributes? KW_INDIRECT? KW_CASE union-style-enum-case-list
  union-style-enum-case-list ::= union-style-enum-case | union-style-enum-case COMMA union-style-enum-case-list
  union-style-enum-case ::= enum-case-name tuple-type?
  enum-name ::= IDENTIFIER
  enum-case-name ::= IDENTIFIER
  raw-value-style-enum ::= KW_ENUM enum-name generic-parameter-clause? type-inheritance-clause generic-where-clause? LBRACE raw-value-style-enum-members RBRACE
  raw-value-style-enum-members ::= raw-value-style-enum-member raw-value-style-enum-members?
  raw-value-style-enum-member ::= declaration | raw-value-style-enum-case-clause | compiler-control-statement
  raw-value-style-enum-case-clause ::= attributes? KW_CASE raw-value-style-enum-case-list
  raw-value-style-enum-case-list ::= raw-value-style-enum-case | raw-value-style-enum-case COMMA raw-value-style-enum-case-list
  raw-value-style-enum-case ::= enum-case-name raw-value-assignment?
  raw-value-assignment ::= OP_ASSIGNMENT raw-value-literal
  raw-value-literal ::= numeric-literal | static-string-literal | boolean-literal
  struct-declaration ::= attributes? access-level-modifier? struct struct-name generic-parameter-clause? type-inheritance-clause? generic-where-clause? struct-body
  struct-name ::= IDENTIFIER
  struct-body ::= LBRACE struct-members? RBRACE
  struct-members ::= struct-member struct-members?
  struct-member ::= declaration | compiler-control-statement
  class-declaration ::= attributes? access-level-modifier? KW_FINAL? KW_CLASS class-name generic-parameter-clause? type-inheritance-clause? generic-where-clause? class-body | attributes? KW_FINAL access-level-modifier? KW_CLASS class-name generic-parameter-clause? type-inheritance-clause? generic-where-clause? class-body
  class-name ::= IDENTIFIER
  class-body ::= LBRACE class-members? RBRACE
  class-members ::= class-member class-members?
  class-member ::= declaration | compiler-control-statement
  actor-declaration ::= attributes? access-level-modifier? KW_ACTOR actor-name generic-parameter-clause? type-inheritance-clause? generic-where-clause? actor-body
  actor-name ::= IDENTIFIER
  actor-body ::= LBRACE actor-members? RBRACE
  actor-members ::= actor-member actor-members?
  actor-member ::= declaration | compiler-control-statement

  protocol-declaration ::= attributes? access-level-modifier? KW_LOWER_PROTOCOL_DECL protocol-name type-inheritance-clause? generic-where-clause? protocol-body
  protocol-name ::= IDENTIFIER
  protocol-body ::= LBRACE protocol-members? RBRACE
  protocol-members ::= protocol-member protocol-members?
  protocol-member ::= protocol-member-declaration | compiler-control-statement
  protocol-member-declaration ::= protocol-property-declaration | protocol-method-declaration | protocol-initializer-declaration | protocol-subscript-declaration | protocol-associated-type-declaration | typealias-declaration | variable-declaration-head variable-name type-annotation getter-setter-keyword-block
  protocol-method-declaration ::= function-head function-name generic-parameter-clause? function-signature generic-where-clause?
  protocol-initializer-declaration ::= initializer-head generic-parameter-clause? parameter-clause throws-clause? generic-where-clause? | initializer-head generic-parameter-clause? parameter-clause KW_RETHROWS generic-where-clause?
  protocol-subscript-declaration ::= subscript-head subscript-result generic-where-clause? getter-setter-keyword-block
  protocol-associated-type-declaration ::= attributes? access-level-modifier? KW_ASSOCIATEDTYPE typealias-name type-inheritance-clause? typealias-assignment? generic-where-clause?
  initializer-declaration ::= initializer-head generic-parameter-clause? parameter-clause KW_ASYNC? throws-clause? generic-where-clause? initializer-body | initializer-head generic-parameter-clause? parameter-clause KW_ASYNC? KW_RETHROWS generic-where-clause? initializer-body
  initializer-head ::= attributes? declaration-modifiers? KW_INIT | attributes? declaration-modifiers? KW_INIT OP_QUESTION | attributes? declaration-modifiers? KW_INIT OP_NOT
  initializer-body ::= code-block
  deinitializer-declaration ::= attributes? KW_DEINIT code-block
  extension-declaration ::= attributes? access-level-modifier? KW_EXTENSION type-identifier type-inheritance-clause? generic-where-clause? extension-body
  extension-body ::= LBRACE extension-members? RBRACE
  extension-members ::= extension-member extension-members?
  extension-member ::= declaration | compiler-control-statement
  subscript-declaration ::= subscript-head subscript-result generic-where-clause? code-block | subscript-head subscript-result generic-where-clause? getter-setter-block | subscript-head subscript-result generic-where-clause? getter-setter-keyword-block
  subscript-head ::= attributes? declaration-modifiers? KW_SUBSCRIPT generic-parameter-clause? parameter-clause
  subscript-result ::= KW_FWD_ARROW attributes? type
  macro-declaration ::= macro-head IDENTIFIER generic-parameter-clause? macro-signature macro-definition? generic-where-clause
  macro-head ::= attributes? declaration-modifiers? KW_MACRO
  macro-signature ::= parameter-clause macro-function-signature-result?
  macro-function-signature-result ::= KW_FWD_ARROW type
  macro-definition ::= OP_ASSIGNMENT expression
  operator-declaration ::= prefix-operator-declaration | postfix-operator-declaration | infix-operator-declaration
  prefix-operator-declaration ::= KW_PREFIX KW_OPERATOR operator
  postfix-operator-declaration ::= KW_POSTFIX KW_OPERATOR operator
  infix-operator-declaration ::= KW_INFIX KW_OPERATOR operator infix-operator-group?
  infix-operator-group ::= COLON precedence-group-name
  precedence-group-declaration ::= KW_PRECEDENCEGROUP precedence-group-name LBRACE precedence-group-attributes? RBRACE
  precedence-group-attributes ::= precedence-group-attribute precedence-group-attributes?
  precedence-group-attribute ::= precedence-group-relation | precedence-group-assignment | precedence-group-associativity
  precedence-group-relation ::= KW_HIGHER_THAN COLON precedence-group-names | KW_LOWER_THAN COLON precedence-group-names
  precedence-group-assignment ::= KW_ASSIGNMENT COLON boolean-literal
  precedence-group-associativity ::= KW_ASSOCIATIVITY COLON left | KW_ASSOCIATIVITY COLON right | KW_ASSOCIATIVITY COLON none
  precedence-group-names ::= precedence-group-name | precedence-group-name COMMA precedence-group-names
  precedence-group-name ::= IDENTIFIER
  declaration-modifier ::= KW_CLASS | KW_CONVENIENCE | KW_DYNAMIC | KW_FINAL | KW_INFIX | KW_LAZY | KW_OPTIONAL | KW_OVERRIDE | KW_POSTFIX | KW_PREFIX | KW_REQUIRED | KW_STATIC | KW_UNOWNED | KW_UNOWNED LPAREN KW_SAFE RPAREN | KW_UNOWNED LPAREN KW_UNSAFE RPAREN | KW_WEAK | access-level-modifier | mutation-modifier | actor-isolation-modifier
  declaration-modifiers ::= declaration-modifier declaration-modifiers?
  access-level-modifier ::= KW_PRIVATE | KW_PRIVATE LPAREN KW_SET RPAREN | KW_FILEPRIVATE | KW_FILEPRIVATE LPAREN KW_SET RPAREN | KW_INTERNAL | KW_INTERNAL LPAREN KW_SET RPAREN | KW_PACKAGE | KW_PACKAGE LPAREN KW_SET RPAREN | KW_PUBLIC | KW_PUBLIC LPAREN KW_SET RPAREN | KW_OPEN | KW_OPEN LPAREN KW_SET RPAREN
  mutation-modifier ::= KW_MUTATING | KW_NONMUTATING
  actor-isolation-modifier ::= KW_NONISOLATED
  // RULES: ATTRIBUTES
  attribute ::= OP_AT attribute-name attribute-argument-clause?
  attribute-name ::= IDENTIFIER
  attribute-argument-clause ::= LPAREN balanced-tokens? RPAREN
  attributes ::= attribute attributes?
  balanced-tokens ::= balanced-token balanced-tokens?
  balanced-token ::= LPAREN balanced-tokens? RPAREN | LBRACKET balanced-tokens? RBRACKET | LBRACE balanced-tokens? RBRACE

// balanced-token → Any identifier, keyword, literal, or operator
// balanced-token → Any punctuation except (, ), [, ], {, or }

  // RULES: PATTERNS
  pattern ::= wildcard-pattern type-annotation? | identifier-pattern type-annotation? | value-binding-pattern | tuple-pattern type-annotation? | enum-case-pattern | optional-pattern | type-casting-pattern | expression-pattern
  wildcard-pattern ::= KW_UNDERSCORE
  identifier-pattern ::= IDENTIFIER
  value-binding-pattern ::= KW_VAR pattern | KW_LET pattern
  tuple-pattern ::= LPAREN tuple-pattern-element-list? RPAREN
  tuple-pattern-element-list ::= tuple-pattern-element | tuple-pattern-element COMMA tuple-pattern-element-list
  tuple-pattern-element ::= pattern | IDENTIFIER COLON pattern
  enum-case-pattern ::= type-identifier? DOT enum-case-name tuple-pattern?
  optional-pattern ::= identifier-pattern OP_QUESTION
  type-casting-pattern ::= is-pattern | as-pattern
  is-pattern ::= OP_TYPE_CHECK type
  as-pattern ::= pattern OP_TYPE_CAST type
  expression-pattern ::= expression
  // RULES: GENERIC PARAMETERS and ARGUMENTS
  generic-parameter-clause ::= OP_LANGLE generic-parameter-list OP_RANGLE
  generic-parameter-list ::= generic-parameter | generic-parameter COMMA generic-parameter-list
  generic-parameter ::= type-name | type-name COLON type-identifier | type-name COLON protocol-composition-type
  generic-where-clause ::= KW_WHERE requirement-list
  requirement-list ::= requirement | requirement COMMA requirement-list
  requirement ::= conformance-requirement | same-type-requirement
  conformance-requirement ::= type-identifier COLON type-identifier | type-identifier COLON protocol-composition-type
  same-type-requirement ::= type-identifier OP_EQ type
  generic-argument-clause ::= OP_LANGLE generic-argument-list OP_RANGLE
  generic-argument-list ::= generic-argument | generic-argument COMMA generic-argument-list
  generic-argument ::= type

  // LEXICAL TOKEN DEFINITIONS:

  // GENERAL/SHARED ACROSS STATES
  token COMMENT_TEXT
  token SINGLELINE_COMMENT
  token QUOTED_IDENTIFIER

  token STRING_INTERPOLATION_START
  token STRING_TEXT
  token STRING_START
  token STRING_END
  token STRING_ESCAPED_SEQUENCE
  token MULTILINE_STRING_START
  token MULTILINE_STRING_END
  token MULTILINE_STRING_ESCAPED_NEWLINE
  token MULTILINE_STRING_ESCAPED_SEQUENCE
  token EXTENDED_STRING_START
  token EXTENDED_STRING_END
  token EXTENDED_MULTILINE_STRING_START
  token EXTENDED_MULTILINE_STRING_END
  token MULTILINE_COMMENT_START
  token MULTILINE_COMMENT_END

  // KEYWORDS (Pound Sign #)
  token KW_PND_AVAILABLE
  token KW_PND_COLORLITERAL
  token KW_PND_ELSE
  token KW_PND_ELSEIF
  token KW_PND_ENDIF
  token KW_PND_FILELITERAL
  token KW_PND_IF
  token KW_PND_IMAGELITERAL
  token KW_PND_KEYPATH
  token KW_PND_SELECTOR
  token KW_PND_SOURCELOCATION
  token KW_PND_UNAVAILABLE

  // KEYWORDS reserved for DISTINCT USE
  token KW_UPPER_ANY
  token KW_LOWER_ANY
  token KW_ASSOCIATEDTYPE
  token KW_AWAIT
  token KW_BORROWING
  token KW_BREAK
  token KW_CASE
  token KW_CLASS
  token KW_CONSUMING
  token KW_CONTINUE
  token KW_DEFAULT
  token KW_DEFER
  token KW_DEINIT
  token KW_DO
  token KW_ELSE
  token KW_ENUM
  token KW_EXTENSION
  token KW_FALLTHROUGH
  token KW_FALSE
  token KW_FILEPRIVATE
  token KW_FOR
  token KW_FUNC
  token KW_GUARD
  token KW_IF
  token KW_IMPORT
  token KW_IN
  token KW_INIT
  token KW_INOUT
  token KW_INTERNAL
  token KW_LET
  token KW_NIL
  token KW_NONISOLATED
  token KW_OPEN
  token KW_OPERATOR
  token KW_PRECEDENCEGROUP
  token KW_PRIVATE
  token KW_LOWER_PROTOCOL_DECL
  token KW_PUBLIC
  token KW_REPEAT
  token KW_RETURN
  token KW_LOWER_SELF
  token KW_UPPER_SELF
  token KW_STATIC
  token KW_STRUCT
  token KW_SUPER
  token KW_SWITCH
  token KW_SUBSCRIPT
  token KW_THROWS
  token KW_TRUE
  token KW_TRY
  token KW_TYPEALIAS
  token KW_VAR
  token KW_WHERE
  token KW_WHILE

  // KEYWORDS reserved for DIFFERING USES depending on the context.
  token KW_CATCH
  token KW_THROW
  token KW_RETHROWS

  // KEYWORDS reserved ONLY IN PARTICULAR CONTEXTS. Outside the context in which they appear in the grammar, they can be used as identifiers.
token KW_ASSOCIATIVITY
token KW_ASYNC
token KW_CONVENIENCE
token KW_DIDSET
token KW_DYNAMIC
token KW_FINAL
token KW_GET
token KW_INDIRECT
token KW_INFIX
token KW_LAZY
token KW_LEFT
token KW_MUTATING
token KW_NONE
token KW_NONMUTATING
token KW_OPTIONAL
token KW_OVERRIDE
token KW_PACKAGE
token KW_POSTFIX
token KW_PRECEDENCE
token KW_PREFIX
token KW_UPPER_PROTOCOL
token KW_REQUIRED
token KW_RIGHT
token KW_SET
token KW_SOME
token KW_UPPER_TYPE
token KW_UNOWNED
token KW_WEAK
token KW_WILLSET

  // KEYWORDS reserved for PATTERNS
  token KW_UNDERSCORE

  // FLOATING POINT LITERALS
  token HEX_FLOATING_POINT_LITERAL
  token DECIMAL_FLOATING_POINT_LITERAL

  // INTEGER LITERALS
  token BINARY_LITERAL
  token OCTAL_LITERAL
  token HEX_LITERAL
  token DECIMAL_LITERAL

  // OPERATORS AND PUNCTUATION (Fixed String Literals)
  token OP_TYPE_CAST_BANG
  token OP_TYPE_CAST_OPT
  token OP_TYPE_CAST
  token OP_TYPE_CHECK
  token OP_OVERFLOW_BITSHIFT_LEFT_AND_ASSIGNMENT
  token OP_OVERFLOW_BITSHIFT_RIGHT_AND_ASSIGNMENT
  token OP_TRIPLE_LANGLE
  token OP_TRIPLE_RANGLE
  token OP_IDENTICAL
  token OP_NOT_IDENTICAL
  token OP_BITSHIFT_LEFT_AND_ASSIGNMENT
  token OP_BITSHIFT_RIGHT_AND_ASSIGNMENT
  token OP_OVERFLOW_BITSHIFT_LEFT
  token OP_OVERFLOW_BITSHIFT_RIGHT
  token OP_HALFOPEN_RANGE
  token OP_CLOSED_RANGE
  token OP_POINTWISE_EQ
  token OP_POINTWISE_NOT_EQ
  token OP_OVERFLOW_ADD_AND_ASSIGNMENT
  token OP_OVERFLOW_SUB_AND_ASSIGNMENT
  token OP_OVERFLOW_MULT_AND_ASSIGNMENT
  token OP_POINTWISE_BITWISE_AND_AND_ASSIGNMENT
  token OP_POINTWISE_BITWISE_OR_AND_ASSIGNMENT
  token OP_POINTWISE_BITWISE_XOR_AND_ASSIGNMENT
  token OP_POINTWISE_LESS_THAN_OR_EQ
  token OP_POINTWISE_GREATER_THAN_OR_EQ
  token OP_EQ
  token OP_LOGICAL_AND
  token OP_OVERFLOW_ADD
  token OP_OVERFLOW_SUB
  token OP_OVERFLOW_MULT
  token OP_BITWISE_AND_ASSIGNMENT
  token OP_BITWISE_OR_ASSIGNMENT
  token OP_BITWISE_XOR_ASSIGNMENT
  token OP_PATTERN_MATCH
  token OP_NOT_EQ
  token OP_BITSHIFT_LEFT
  token OP_BITSHIFT_RIGHT
  token OP_LESS_THAN_OR_EQ
  token OP_GREATER_THAN_OR_EQ
  token OP_POINTWISE_LESS_THAN
  token OP_POINTWISE_GREATER_THAN
  token OP_ADD_ASSIGNMENT
  token OP_SUB_ASSIGNMENT
  token OP_MULT_ASSIGNMENT
  token OP_DIV_ASSIGNMENT
  token OP_MODULO_ASSIGNMENT
  token OP_LOGICAL_OR
  token OP_POINTWISE_BITWISE_OR
  token OP_POINTWISE_BITWISE_XOR
  token OP_POINTWISE_NOT
  token OP_NIL_COALESCING
  token OP_TERNARY_CONDITIONAL
  token FWD_ARROW

  // SPECIAL: RPAREN
  token STRING_INTERPOLATION_END
  token RPAREN

  // FIXIE SINGLE-CHAR PUNCTUATION:
  token LPAREN
  token AT_SYMBOL
  token POUND
  token LBRACE
  token RBRACE
  token LBRACKET
  token RBRACKET
  token COMMA
  token COLON
  token SEMICOLON
  token DOT
  token BACKSLASH

  // FIXIE SINGLE-CHARs that CAN ALSO START CUSTOM OPERATORS
  token FWDSLASH
  token OP_ASSIGNMENT
  token OP_ADD
  token OP_SUB
  token OP_MULT
  token OP_MODULO
  token OP_NOT
  token OP_LANGLE
  token OP_RANGLE
  token OP_BITWISE_AND
  token OP_BITWISE_OR
  token OP_BITWISE_XOR
  token OP_BITWISE_NOT
  token OP_QUESTION

  // IMPLICIT PARAMETER NAMES, PROPERTY WRAPPER PROJECTIONS
  token IMPLICIT_PARAMETER_NAME
  token PROPERTY_WRAPPER_PROJECTION

  // CUSTOM OPERATORS
  token DOT_OPERATOR
  token OPERATOR
  token IDENTIFIER

  // TOKENS: REGEX LITERALS (FUTURE)

  // END FILE Swift.bnf